
Caterina.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a8  00800100  00007f1a  00000fae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f1a  00007000  00007000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000016  008001a8  008001a8  00001056  2**0
                  ALLOC
  3 .debug_aranges 000002d8  00000000  00000000  00001056  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000007ce  00000000  00000000  0000132e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004943  00000000  00000000  00001afc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000011ad  00000000  00000000  0000643f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000467e  00000000  00000000  000075ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000430  00000000  00000000  0000bc6c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00002153  00000000  00000000  0000c09c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002953  00000000  00000000  0000e1ef  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000388  00000000  00000000  00010b42  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
	return true;
#endif
}

void Endpoint_ClearEndpoints(void)
{
    7000:	55 c0       	rjmp	.+170    	; 0x70ac <__ctors_end>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
    7002:	00 00       	nop

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    7004:	6e c0       	rjmp	.+220    	; 0x70e2 <__bad_interrupt>
    7006:	00 00       	nop
    7008:	6c c0       	rjmp	.+216    	; 0x70e2 <__bad_interrupt>
    700a:	00 00       	nop
    700c:	6a c0       	rjmp	.+212    	; 0x70e2 <__bad_interrupt>
    700e:	00 00       	nop
    7010:	68 c0       	rjmp	.+208    	; 0x70e2 <__bad_interrupt>
    7012:	00 00       	nop
    7014:	66 c0       	rjmp	.+204    	; 0x70e2 <__bad_interrupt>
    7016:	00 00       	nop
    7018:	64 c0       	rjmp	.+200    	; 0x70e2 <__bad_interrupt>
    701a:	00 00       	nop
    701c:	62 c0       	rjmp	.+196    	; 0x70e2 <__bad_interrupt>
    701e:	00 00       	nop
    7020:	60 c0       	rjmp	.+192    	; 0x70e2 <__bad_interrupt>
    7022:	00 00       	nop
    7024:	5e c0       	rjmp	.+188    	; 0x70e2 <__bad_interrupt>
    7026:	00 00       	nop
    7028:	fc c4       	rjmp	.+2552   	; 0x7a22 <__vector_10>
    702a:	00 00       	nop
    702c:	5a c0       	rjmp	.+180    	; 0x70e2 <__bad_interrupt>
    702e:	00 00       	nop
    7030:	58 c0       	rjmp	.+176    	; 0x70e2 <__bad_interrupt>
    7032:	00 00       	nop
    7034:	56 c0       	rjmp	.+172    	; 0x70e2 <__bad_interrupt>
    7036:	00 00       	nop
    7038:	54 c0       	rjmp	.+168    	; 0x70e2 <__bad_interrupt>
    703a:	00 00       	nop
    703c:	52 c0       	rjmp	.+164    	; 0x70e2 <__bad_interrupt>
    703e:	00 00       	nop
    7040:	50 c0       	rjmp	.+160    	; 0x70e2 <__bad_interrupt>
    7042:	00 00       	nop
    7044:	81 c0       	rjmp	.+258    	; 0x7148 <__vector_17>
    7046:	00 00       	nop
    7048:	4c c0       	rjmp	.+152    	; 0x70e2 <__bad_interrupt>
    704a:	00 00       	nop
    704c:	4a c0       	rjmp	.+148    	; 0x70e2 <__bad_interrupt>
    704e:	00 00       	nop
    7050:	48 c0       	rjmp	.+144    	; 0x70e2 <__bad_interrupt>
    7052:	00 00       	nop
    7054:	46 c0       	rjmp	.+140    	; 0x70e2 <__bad_interrupt>
    7056:	00 00       	nop
    7058:	44 c0       	rjmp	.+136    	; 0x70e2 <__bad_interrupt>
    705a:	00 00       	nop
    705c:	42 c0       	rjmp	.+132    	; 0x70e2 <__bad_interrupt>
    705e:	00 00       	nop
    7060:	40 c0       	rjmp	.+128    	; 0x70e2 <__bad_interrupt>
    7062:	00 00       	nop
    7064:	3e c0       	rjmp	.+124    	; 0x70e2 <__bad_interrupt>
    7066:	00 00       	nop
    7068:	3c c0       	rjmp	.+120    	; 0x70e2 <__bad_interrupt>
    706a:	00 00       	nop
    706c:	3a c0       	rjmp	.+116    	; 0x70e2 <__bad_interrupt>
    706e:	00 00       	nop
    7070:	38 c0       	rjmp	.+112    	; 0x70e2 <__bad_interrupt>
    7072:	00 00       	nop
    7074:	36 c0       	rjmp	.+108    	; 0x70e2 <__bad_interrupt>
    7076:	00 00       	nop
    7078:	34 c0       	rjmp	.+104    	; 0x70e2 <__bad_interrupt>
    707a:	00 00       	nop
    707c:	32 c0       	rjmp	.+100    	; 0x70e2 <__bad_interrupt>
    707e:	00 00       	nop
    7080:	30 c0       	rjmp	.+96     	; 0x70e2 <__bad_interrupt>
    7082:	00 00       	nop
    7084:	2e c0       	rjmp	.+92     	; 0x70e2 <__bad_interrupt>
    7086:	00 00       	nop
    7088:	2c c0       	rjmp	.+88     	; 0x70e2 <__bad_interrupt>
    708a:	00 00       	nop
    708c:	2a c0       	rjmp	.+84     	; 0x70e2 <__bad_interrupt>
    708e:	00 00       	nop
    7090:	28 c0       	rjmp	.+80     	; 0x70e2 <__bad_interrupt>
    7092:	00 00       	nop
    7094:	26 c0       	rjmp	.+76     	; 0x70e2 <__bad_interrupt>
    7096:	00 00       	nop
    7098:	24 c0       	rjmp	.+72     	; 0x70e2 <__bad_interrupt>
    709a:	00 00       	nop
    709c:	22 c0       	rjmp	.+68     	; 0x70e2 <__bad_interrupt>
    709e:	00 00       	nop
    70a0:	20 c0       	rjmp	.+64     	; 0x70e2 <__bad_interrupt>
    70a2:	00 00       	nop
    70a4:	1e c0       	rjmp	.+60     	; 0x70e2 <__bad_interrupt>
    70a6:	00 00       	nop
    70a8:	1c c0       	rjmp	.+56     	; 0x70e2 <__bad_interrupt>
    70aa:	00 00       	nop

000070ac <__ctors_end>:
    70ac:	11 24       	eor	r1, r1
    70ae:	1f be       	out	0x3f, r1	; 63
    70b0:	cf ef       	ldi	r28, 0xFF	; 255
    70b2:	da e0       	ldi	r29, 0x0A	; 10
    70b4:	de bf       	out	0x3e, r29	; 62
    70b6:	cd bf       	out	0x3d, r28	; 61

000070b8 <__do_copy_data>:
    70b8:	11 e0       	ldi	r17, 0x01	; 1
    70ba:	a0 e0       	ldi	r26, 0x00	; 0
    70bc:	b1 e0       	ldi	r27, 0x01	; 1
    70be:	ea e1       	ldi	r30, 0x1A	; 26
    70c0:	ff e7       	ldi	r31, 0x7F	; 127
    70c2:	02 c0       	rjmp	.+4      	; 0x70c8 <.do_copy_data_start>

000070c4 <.do_copy_data_loop>:
    70c4:	05 90       	lpm	r0, Z+
    70c6:	0d 92       	st	X+, r0

000070c8 <.do_copy_data_start>:
    70c8:	a8 3a       	cpi	r26, 0xA8	; 168
    70ca:	b1 07       	cpc	r27, r17
    70cc:	d9 f7       	brne	.-10     	; 0x70c4 <.do_copy_data_loop>

000070ce <__do_clear_bss>:
    70ce:	11 e0       	ldi	r17, 0x01	; 1
    70d0:	a8 ea       	ldi	r26, 0xA8	; 168
    70d2:	b1 e0       	ldi	r27, 0x01	; 1
    70d4:	01 c0       	rjmp	.+2      	; 0x70d8 <.do_clear_bss_start>

000070d6 <.do_clear_bss_loop>:
    70d6:	1d 92       	st	X+, r1

000070d8 <.do_clear_bss_start>:
    70d8:	ae 3b       	cpi	r26, 0xBE	; 190
    70da:	b1 07       	cpc	r27, r17
    70dc:	e1 f7       	brne	.-8      	; 0x70d6 <.do_clear_bss_loop>
    70de:	99 d3       	rcall	.+1842   	; 0x7812 <main>
    70e0:	1a c7       	rjmp	.+3636   	; 0x7f16 <_exit>

000070e2 <__bad_interrupt>:
    70e2:	8e cf       	rjmp	.-228    	; 0x7000 <__vectors>

000070e4 <StartSketch>:
uint16_t bootKey = 0x7777;
volatile uint16_t *const bootKeyPtr = (volatile uint16_t *)0x0800;

void StartSketch(void)
{
	cli();
    70e4:	f8 94       	cli
	
	/* Undo TIMER1 setup and clear the count before running the sketch */
	TIMSK1 = 0;
    70e6:	10 92 6f 00 	sts	0x006F, r1
	TCCR1B = 0;
    70ea:	10 92 81 00 	sts	0x0081, r1
	TCNT1H = 0;		// 16-bit write to TCNT1 requires high byte be written first
    70ee:	10 92 85 00 	sts	0x0085, r1
	TCNT1L = 0;
    70f2:	10 92 84 00 	sts	0x0084, r1
	
	/* Relocate the interrupt vector table to the application section */
	MCUCR = (1 << IVCE);
    70f6:	81 e0       	ldi	r24, 0x01	; 1
    70f8:	85 bf       	out	0x35, r24	; 53
	MCUCR = 0;
    70fa:	15 be       	out	0x35, r1	; 53

	L_LED_OFF();
    70fc:	85 b1       	in	r24, 0x05	; 5
    70fe:	8f 67       	ori	r24, 0x7F	; 127
    7100:	85 b9       	out	0x05, r24	; 5
	TX_LED_OFF();
    7102:	85 b1       	in	r24, 0x05	; 5
    7104:	8f 6d       	ori	r24, 0xDF	; 223
    7106:	85 b9       	out	0x05, r24	; 5
	RX_LED_OFF();
    7108:	85 b1       	in	r24, 0x05	; 5
    710a:	8f 6b       	ori	r24, 0xBF	; 191
    710c:	85 b9       	out	0x05, r24	; 5

	/* jump to beginning of application space */
	__asm__ volatile("jmp 0x0000");
    710e:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
}
    7112:	08 95       	ret

00007114 <LEDPulse>:

/*	Breathing animation on L LED indicates bootloader is running */
uint16_t LLEDPulse;
void LEDPulse(void)
{
	LLEDPulse++;
    7114:	20 91 b2 01 	lds	r18, 0x01B2
    7118:	30 91 b3 01 	lds	r19, 0x01B3
    711c:	2f 5f       	subi	r18, 0xFF	; 255
    711e:	3f 4f       	sbci	r19, 0xFF	; 255
    7120:	30 93 b3 01 	sts	0x01B3, r19
    7124:	20 93 b2 01 	sts	0x01B2, r18
	uint8_t p = LLEDPulse >> 8;
    7128:	93 2f       	mov	r25, r19
	if (p > 127)
    712a:	37 ff       	sbrs	r19, 7
    712c:	03 c0       	rjmp	.+6      	; 0x7134 <LEDPulse+0x20>
		p = 254-p;
    712e:	8e ef       	ldi	r24, 0xFE	; 254
    7130:	83 1b       	sub	r24, r19
    7132:	98 2f       	mov	r25, r24
	p += p;
	if (((uint8_t)LLEDPulse) > p)
    7134:	99 0f       	add	r25, r25
    7136:	92 17       	cp	r25, r18
    7138:	18 f4       	brcc	.+6      	; 0x7140 <LEDPulse+0x2c>
		L_LED_OFF();
    713a:	85 b1       	in	r24, 0x05	; 5
    713c:	8f 67       	ori	r24, 0x7F	; 127
    713e:	02 c0       	rjmp	.+4      	; 0x7144 <LEDPulse+0x30>
	else
		L_LED_ON();
    7140:	85 b1       	in	r24, 0x05	; 5
    7142:	80 78       	andi	r24, 0x80	; 128
    7144:	85 b9       	out	0x05, r24	; 5
    7146:	08 95       	ret

00007148 <__vector_17>:
	USB_Init();
}

//uint16_t ctr = 0;
ISR(TIMER1_COMPA_vect, ISR_BLOCK)
{
    7148:	1f 92       	push	r1
    714a:	0f 92       	push	r0
    714c:	0f b6       	in	r0, 0x3f	; 63
    714e:	0f 92       	push	r0
    7150:	11 24       	eor	r1, r1
    7152:	2f 93       	push	r18
    7154:	8f 93       	push	r24
    7156:	9f 93       	push	r25
    7158:	ef 93       	push	r30
    715a:	ff 93       	push	r31
	/* Reset counter */
	TCNT1H = 0;
    715c:	10 92 85 00 	sts	0x0085, r1
	TCNT1L = 0;
    7160:	10 92 84 00 	sts	0x0084, r1

	/* Check whether the TX or RX LED one-shot period has elapsed.  if so, turn off the LED */
	if (TxLEDPulse && !(--TxLEDPulse))
    7164:	80 91 a8 01 	lds	r24, 0x01A8
    7168:	90 91 a9 01 	lds	r25, 0x01A9
    716c:	00 97       	sbiw	r24, 0x00	; 0
    716e:	51 f0       	breq	.+20     	; 0x7184 <__vector_17+0x3c>
    7170:	01 97       	sbiw	r24, 0x01	; 1
    7172:	90 93 a9 01 	sts	0x01A9, r25
    7176:	80 93 a8 01 	sts	0x01A8, r24
    717a:	89 2b       	or	r24, r25
    717c:	19 f4       	brne	.+6      	; 0x7184 <__vector_17+0x3c>
		TX_LED_OFF();
    717e:	85 b1       	in	r24, 0x05	; 5
    7180:	8f 6d       	ori	r24, 0xDF	; 223
    7182:	85 b9       	out	0x05, r24	; 5
	if (RxLEDPulse && !(--RxLEDPulse))
    7184:	80 91 aa 01 	lds	r24, 0x01AA
    7188:	90 91 ab 01 	lds	r25, 0x01AB
    718c:	00 97       	sbiw	r24, 0x00	; 0
    718e:	51 f0       	breq	.+20     	; 0x71a4 <__vector_17+0x5c>
    7190:	01 97       	sbiw	r24, 0x01	; 1
    7192:	90 93 ab 01 	sts	0x01AB, r25
    7196:	80 93 aa 01 	sts	0x01AA, r24
    719a:	89 2b       	or	r24, r25
    719c:	19 f4       	brne	.+6      	; 0x71a4 <__vector_17+0x5c>
		RX_LED_OFF();
    719e:	85 b1       	in	r24, 0x05	; 5
    71a0:	8f 6b       	ori	r24, 0xBF	; 191
    71a2:	85 b9       	out	0x05, r24	; 5
	
	if (pgm_read_word(0) != 0xFFFF)
    71a4:	e0 e0       	ldi	r30, 0x00	; 0
    71a6:	f0 e0       	ldi	r31, 0x00	; 0
    71a8:	85 91       	lpm	r24, Z+
    71aa:	94 91       	lpm	r25, Z+
    71ac:	8f 5f       	subi	r24, 0xFF	; 255
    71ae:	9f 4f       	sbci	r25, 0xFF	; 255
    71b0:	49 f0       	breq	.+18     	; 0x71c4 <__vector_17+0x7c>
		Timeout++;
    71b2:	80 91 ac 01 	lds	r24, 0x01AC
    71b6:	90 91 ad 01 	lds	r25, 0x01AD
    71ba:	01 96       	adiw	r24, 0x01	; 1
    71bc:	90 93 ad 01 	sts	0x01AD, r25
    71c0:	80 93 ac 01 	sts	0x01AC, r24
}
    71c4:	ff 91       	pop	r31
    71c6:	ef 91       	pop	r30
    71c8:	9f 91       	pop	r25
    71ca:	8f 91       	pop	r24
    71cc:	2f 91       	pop	r18
    71ce:	0f 90       	pop	r0
    71d0:	0f be       	out	0x3f, r0	; 63
    71d2:	0f 90       	pop	r0
    71d4:	1f 90       	pop	r1
    71d6:	18 95       	reti

000071d8 <FetchNextCommandByte>:
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    71d8:	84 e0       	ldi	r24, 0x04	; 4
    71da:	80 93 e9 00 	sts	0x00E9, r24
    71de:	0d c0       	rjmp	.+26     	; 0x71fa <FetchNextCommandByte+0x22>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    71e0:	80 91 e8 00 	lds	r24, 0x00E8
    71e4:	8b 77       	andi	r24, 0x7B	; 123
    71e6:	80 93 e8 00 	sts	0x00E8, r24
    71ea:	03 c0       	rjmp	.+6      	; 0x71f2 <FetchNextCommandByte+0x1a>
	{
		Endpoint_ClearOUT();

		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    71ec:	8e b3       	in	r24, 0x1e	; 30
    71ee:	88 23       	and	r24, r24
    71f0:	51 f0       	breq	.+20     	; 0x7206 <FetchNextCommandByte+0x2e>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    71f2:	80 91 e8 00 	lds	r24, 0x00E8
	/* If OUT endpoint empty, clear it and wait for the next packet from the host */
	while (!(Endpoint_IsReadWriteAllowed()))
	{
		Endpoint_ClearOUT();

		while (!(Endpoint_IsOUTReceived()))
    71f6:	82 ff       	sbrs	r24, 2
    71f8:	f9 cf       	rjmp	.-14     	; 0x71ec <FetchNextCommandByte+0x14>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    71fa:	80 91 e8 00 	lds	r24, 0x00E8
{
	/* Select the OUT endpoint so that the next data byte can be read */
	Endpoint_SelectEndpoint(CDC_RX_EPNUM);

	/* If OUT endpoint empty, clear it and wait for the next packet from the host */
	while (!(Endpoint_IsReadWriteAllowed()))
    71fe:	85 ff       	sbrs	r24, 5
    7200:	ef cf       	rjmp	.-34     	; 0x71e0 <FetchNextCommandByte+0x8>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    7202:	80 91 f1 00 	lds	r24, 0x00F1
		}
	}

	/* Fetch the next byte from the OUT endpoint */
	return Endpoint_Read_8();
}
    7206:	08 95       	ret

00007208 <WriteNextResponseByte>:
 *  bank when full ready for the next byte in the packet to the host.
 *
 *  \param[in] Response  Next response byte to send to the host
 */
static void WriteNextResponseByte(const uint8_t Response)
{
    7208:	98 2f       	mov	r25, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    720a:	83 e0       	ldi	r24, 0x03	; 3
    720c:	80 93 e9 00 	sts	0x00E9, r24
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    7210:	80 91 e8 00 	lds	r24, 0x00E8
	/* Select the IN endpoint so that the next data byte can be written */
	Endpoint_SelectEndpoint(CDC_TX_EPNUM);

	/* If IN endpoint full, clear it and wait until ready for the next packet to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    7214:	85 fd       	sbrc	r24, 5
    7216:	0d c0       	rjmp	.+26     	; 0x7232 <WriteNextResponseByte+0x2a>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7218:	80 91 e8 00 	lds	r24, 0x00E8
    721c:	8e 77       	andi	r24, 0x7E	; 126
    721e:	80 93 e8 00 	sts	0x00E8, r24
    7222:	03 c0       	rjmp	.+6      	; 0x722a <WriteNextResponseByte+0x22>
	{
		Endpoint_ClearIN();

		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    7224:	8e b3       	in	r24, 0x1e	; 30
    7226:	88 23       	and	r24, r24
    7228:	79 f0       	breq	.+30     	; 0x7248 <WriteNextResponseByte+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    722a:	80 91 e8 00 	lds	r24, 0x00E8
	/* If IN endpoint full, clear it and wait until ready for the next packet to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
	{
		Endpoint_ClearIN();

		while (!(Endpoint_IsINReady()))
    722e:	80 ff       	sbrs	r24, 0
    7230:	f9 cf       	rjmp	.-14     	; 0x7224 <WriteNextResponseByte+0x1c>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    7232:	90 93 f1 00 	sts	0x00F1, r25
	}

	/* Write the next byte to the IN endpoint */
	Endpoint_Write_8(Response);
	
	TX_LED_ON();
    7236:	85 b1       	in	r24, 0x05	; 5
    7238:	80 72       	andi	r24, 0x20	; 32
    723a:	85 b9       	out	0x05, r24	; 5
	TxLEDPulse = TX_RX_LED_PULSE_PERIOD;
    723c:	84 e6       	ldi	r24, 0x64	; 100
    723e:	90 e0       	ldi	r25, 0x00	; 0
    7240:	90 93 a9 01 	sts	0x01A9, r25
    7244:	80 93 a8 01 	sts	0x01A8, r24
    7248:	08 95       	ret

0000724a <CDC_Task>:

/** Task to read in AVR910 commands from the CDC data OUT endpoint, process them, perform the required actions
 *  and send the appropriate response back to the host.
 */
void CDC_Task(void)
{
    724a:	4f 92       	push	r4
    724c:	5f 92       	push	r5
    724e:	6f 92       	push	r6
    7250:	7f 92       	push	r7
    7252:	8f 92       	push	r8
    7254:	9f 92       	push	r9
    7256:	af 92       	push	r10
    7258:	bf 92       	push	r11
    725a:	cf 92       	push	r12
    725c:	df 92       	push	r13
    725e:	ef 92       	push	r14
    7260:	ff 92       	push	r15
    7262:	0f 93       	push	r16
    7264:	1f 93       	push	r17
    7266:	cf 93       	push	r28
    7268:	df 93       	push	r29
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    726a:	84 e0       	ldi	r24, 0x04	; 4
    726c:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7270:	80 91 e8 00 	lds	r24, 0x00E8
	/* Select the OUT endpoint */
	Endpoint_SelectEndpoint(CDC_RX_EPNUM);

	/* Check if endpoint has a command in it sent from the host */
	if (!(Endpoint_IsOUTReceived()))
    7274:	82 ff       	sbrs	r24, 2
    7276:	4c c2       	rjmp	.+1176   	; 0x7710 <CDC_Task+0x4c6>
	  return;
	  
	RX_LED_ON();
    7278:	85 b1       	in	r24, 0x05	; 5
    727a:	80 74       	andi	r24, 0x40	; 64
    727c:	85 b9       	out	0x05, r24	; 5
	RxLEDPulse = TX_RX_LED_PULSE_PERIOD;
    727e:	84 e6       	ldi	r24, 0x64	; 100
    7280:	90 e0       	ldi	r25, 0x00	; 0
    7282:	90 93 ab 01 	sts	0x01AB, r25
    7286:	80 93 aa 01 	sts	0x01AA, r24

	/* Read in the bootloader command (first byte sent from host) */
	uint8_t Command = FetchNextCommandByte();
    728a:	a6 df       	rcall	.-180    	; 0x71d8 <FetchNextCommandByte>
    728c:	18 2f       	mov	r17, r24

	if (Command == 'E')
    728e:	85 34       	cpi	r24, 0x45	; 69
    7290:	81 f4       	brne	.+32     	; 0x72b2 <CDC_Task+0x68>
	{
		/* We nearly run out the bootloader timeout clock, 
		* leaving just a few hundred milliseconds so the 
		* bootloder has time to respond and service any 
		* subsequent requests */
		Timeout = TIMEOUT_PERIOD - 500;
    7292:	8c e4       	ldi	r24, 0x4C	; 76
    7294:	9d e1       	ldi	r25, 0x1D	; 29
    7296:	90 93 ad 01 	sts	0x01AD, r25
    729a:	80 93 ac 01 	sts	0x01AC, r24
	
		/* Re-enable RWW section - must be done here in case 
		 * user has disabled verification on upload.  */
		boot_rww_enable_safe();		
    729e:	07 b6       	in	r0, 0x37	; 55
    72a0:	00 fc       	sbrc	r0, 0
    72a2:	fd cf       	rjmp	.-6      	; 0x729e <CDC_Task+0x54>
    72a4:	f9 99       	sbic	0x1f, 1	; 31
    72a6:	fe cf       	rjmp	.-4      	; 0x72a4 <CDC_Task+0x5a>
    72a8:	81 e1       	ldi	r24, 0x11	; 17
    72aa:	80 93 57 00 	sts	0x0057, r24
    72ae:	e8 95       	spm
    72b0:	03 c0       	rjmp	.+6      	; 0x72b8 <CDC_Task+0x6e>

		// Send confirmation byte back to the host 
		WriteNextResponseByte('\r');
	}
	else if (Command == 'T')
    72b2:	84 35       	cpi	r24, 0x54	; 84
    72b4:	19 f4       	brne	.+6      	; 0x72bc <CDC_Task+0x72>
	{
		FetchNextCommandByte();
    72b6:	90 df       	rcall	.-224    	; 0x71d8 <FetchNextCommandByte>

		// Send confirmation byte back to the host 
		WriteNextResponseByte('\r');
    72b8:	8d e0       	ldi	r24, 0x0D	; 13
    72ba:	00 c2       	rjmp	.+1024   	; 0x76bc <CDC_Task+0x472>
	}
	else if ((Command == 'L') || (Command == 'P'))
    72bc:	8c 34       	cpi	r24, 0x4C	; 76
    72be:	e1 f3       	breq	.-8      	; 0x72b8 <CDC_Task+0x6e>
    72c0:	80 35       	cpi	r24, 0x50	; 80
    72c2:	d1 f3       	breq	.-12     	; 0x72b8 <CDC_Task+0x6e>
	{
		// Send confirmation byte back to the host 
		WriteNextResponseByte('\r');
	}
	else if (Command == 't')
    72c4:	84 37       	cpi	r24, 0x74	; 116
    72c6:	21 f4       	brne	.+8      	; 0x72d0 <CDC_Task+0x86>
	{
		// Return ATMEGA128 part code - this is only to allow AVRProg to use the bootloader 
		WriteNextResponseByte(0x44);
    72c8:	84 e4       	ldi	r24, 0x44	; 68
    72ca:	9e df       	rcall	.-196    	; 0x7208 <WriteNextResponseByte>
		WriteNextResponseByte(0x00);
    72cc:	80 e0       	ldi	r24, 0x00	; 0
    72ce:	f6 c1       	rjmp	.+1004   	; 0x76bc <CDC_Task+0x472>
	}
	else if (Command == 'a')
    72d0:	81 36       	cpi	r24, 0x61	; 97
    72d2:	11 f4       	brne	.+4      	; 0x72d8 <CDC_Task+0x8e>
	{
		// Indicate auto-address increment is supported 
		WriteNextResponseByte('Y');
    72d4:	89 e5       	ldi	r24, 0x59	; 89
    72d6:	f2 c1       	rjmp	.+996    	; 0x76bc <CDC_Task+0x472>
	}
	else if (Command == 'A')
    72d8:	81 34       	cpi	r24, 0x41	; 65
    72da:	f1 f4       	brne	.+60     	; 0x7318 <CDC_Task+0xce>
	{
		// Set the current address to that given by the host 
		CurrAddress   = (FetchNextCommandByte() << 9);
    72dc:	7d df       	rcall	.-262    	; 0x71d8 <FetchNextCommandByte>
    72de:	18 2f       	mov	r17, r24
		CurrAddress  |= (FetchNextCommandByte() << 1);
    72e0:	7b df       	rcall	.-266    	; 0x71d8 <FetchNextCommandByte>
    72e2:	90 e0       	ldi	r25, 0x00	; 0
    72e4:	88 0f       	add	r24, r24
    72e6:	99 1f       	adc	r25, r25
    72e8:	aa 27       	eor	r26, r26
    72ea:	97 fd       	sbrc	r25, 7
    72ec:	a0 95       	com	r26
    72ee:	ba 2f       	mov	r27, r26
    72f0:	31 2f       	mov	r19, r17
    72f2:	33 0f       	add	r19, r19
    72f4:	20 e0       	ldi	r18, 0x00	; 0
    72f6:	44 27       	eor	r20, r20
    72f8:	37 fd       	sbrc	r19, 7
    72fa:	40 95       	com	r20
    72fc:	54 2f       	mov	r21, r20
    72fe:	82 2b       	or	r24, r18
    7300:	93 2b       	or	r25, r19
    7302:	a4 2b       	or	r26, r20
    7304:	b5 2b       	or	r27, r21
    7306:	80 93 ae 01 	sts	0x01AE, r24
    730a:	90 93 af 01 	sts	0x01AF, r25
    730e:	a0 93 b0 01 	sts	0x01B0, r26
    7312:	b0 93 b1 01 	sts	0x01B1, r27
    7316:	d0 cf       	rjmp	.-96     	; 0x72b8 <CDC_Task+0x6e>

		// Send confirmation byte back to the host 
		WriteNextResponseByte('\r');
	}
	else if (Command == 'p')
    7318:	80 37       	cpi	r24, 0x70	; 112
    731a:	11 f4       	brne	.+4      	; 0x7320 <CDC_Task+0xd6>
	{
		// Indicate serial programmer back to the host 
		WriteNextResponseByte('S');
    731c:	83 e5       	ldi	r24, 0x53	; 83
    731e:	ce c1       	rjmp	.+924    	; 0x76bc <CDC_Task+0x472>
	}
	else if (Command == 'S')
    7320:	83 35       	cpi	r24, 0x53	; 83
    7322:	49 f4       	brne	.+18     	; 0x7336 <CDC_Task+0xec>
    7324:	c0 e0       	ldi	r28, 0x00	; 0
    7326:	d1 e0       	ldi	r29, 0x01	; 1
	{
		// Write the 7-byte software identifier to the endpoint 
		for (uint8_t CurrByte = 0; CurrByte < 7; CurrByte++)
		  WriteNextResponseByte(SOFTWARE_IDENTIFIER[CurrByte]);
    7328:	89 91       	ld	r24, Y+
    732a:	6e df       	rcall	.-292    	; 0x7208 <WriteNextResponseByte>
		WriteNextResponseByte('S');
	}
	else if (Command == 'S')
	{
		// Write the 7-byte software identifier to the endpoint 
		for (uint8_t CurrByte = 0; CurrByte < 7; CurrByte++)
    732c:	21 e0       	ldi	r18, 0x01	; 1
    732e:	c7 30       	cpi	r28, 0x07	; 7
    7330:	d2 07       	cpc	r29, r18
    7332:	d1 f7       	brne	.-12     	; 0x7328 <CDC_Task+0xde>
    7334:	c4 c1       	rjmp	.+904    	; 0x76be <CDC_Task+0x474>
		  WriteNextResponseByte(SOFTWARE_IDENTIFIER[CurrByte]);
	}
	else if (Command == 'V')
    7336:	86 35       	cpi	r24, 0x56	; 86
    7338:	21 f4       	brne	.+8      	; 0x7342 <CDC_Task+0xf8>
	{
		WriteNextResponseByte('0' + BOOTLOADER_VERSION_MAJOR);
    733a:	81 e3       	ldi	r24, 0x31	; 49
    733c:	65 df       	rcall	.-310    	; 0x7208 <WriteNextResponseByte>
		WriteNextResponseByte('0' + BOOTLOADER_VERSION_MINOR);
    733e:	80 e3       	ldi	r24, 0x30	; 48
    7340:	bd c1       	rjmp	.+890    	; 0x76bc <CDC_Task+0x472>
	}
	else if (Command == 's')
    7342:	83 37       	cpi	r24, 0x73	; 115
    7344:	31 f4       	brne	.+12     	; 0x7352 <CDC_Task+0x108>
	{
		WriteNextResponseByte(AVR_SIGNATURE_3);
    7346:	87 e8       	ldi	r24, 0x87	; 135
    7348:	5f df       	rcall	.-322    	; 0x7208 <WriteNextResponseByte>
		WriteNextResponseByte(AVR_SIGNATURE_2);
    734a:	85 e9       	ldi	r24, 0x95	; 149
    734c:	5d df       	rcall	.-326    	; 0x7208 <WriteNextResponseByte>
		WriteNextResponseByte(AVR_SIGNATURE_1);
    734e:	8e e1       	ldi	r24, 0x1E	; 30
    7350:	b5 c1       	rjmp	.+874    	; 0x76bc <CDC_Task+0x472>
	}
	else if (Command == 'e')
    7352:	85 36       	cpi	r24, 0x65	; 101
    7354:	b9 f4       	brne	.+46     	; 0x7384 <CDC_Task+0x13a>
    7356:	e0 e0       	ldi	r30, 0x00	; 0
    7358:	f0 e0       	ldi	r31, 0x00	; 0
	{
		// Clear the application section of flash 
		for (uint32_t CurrFlashAddress = 0; CurrFlashAddress < BOOT_START_ADDR; CurrFlashAddress += SPM_PAGESIZE)
		{
			boot_page_erase(CurrFlashAddress);
    735a:	93 e0       	ldi	r25, 0x03	; 3
			boot_spm_busy_wait();
			boot_page_write(CurrFlashAddress);
    735c:	85 e0       	ldi	r24, 0x05	; 5
	else if (Command == 'e')
	{
		// Clear the application section of flash 
		for (uint32_t CurrFlashAddress = 0; CurrFlashAddress < BOOT_START_ADDR; CurrFlashAddress += SPM_PAGESIZE)
		{
			boot_page_erase(CurrFlashAddress);
    735e:	90 93 57 00 	sts	0x0057, r25
    7362:	e8 95       	spm
			boot_spm_busy_wait();
    7364:	07 b6       	in	r0, 0x37	; 55
    7366:	00 fc       	sbrc	r0, 0
    7368:	fd cf       	rjmp	.-6      	; 0x7364 <CDC_Task+0x11a>
			boot_page_write(CurrFlashAddress);
    736a:	80 93 57 00 	sts	0x0057, r24
    736e:	e8 95       	spm
			boot_spm_busy_wait();
    7370:	07 b6       	in	r0, 0x37	; 55
    7372:	00 fc       	sbrc	r0, 0
    7374:	fd cf       	rjmp	.-6      	; 0x7370 <CDC_Task+0x126>
    7376:	e0 58       	subi	r30, 0x80	; 128
    7378:	ff 4f       	sbci	r31, 0xFF	; 255
		WriteNextResponseByte(AVR_SIGNATURE_1);
	}
	else if (Command == 'e')
	{
		// Clear the application section of flash 
		for (uint32_t CurrFlashAddress = 0; CurrFlashAddress < BOOT_START_ADDR; CurrFlashAddress += SPM_PAGESIZE)
    737a:	a0 e7       	ldi	r26, 0x70	; 112
    737c:	e0 30       	cpi	r30, 0x00	; 0
    737e:	fa 07       	cpc	r31, r26
    7380:	71 f7       	brne	.-36     	; 0x735e <CDC_Task+0x114>
    7382:	9a cf       	rjmp	.-204    	; 0x72b8 <CDC_Task+0x6e>

		// Send confirmation byte back to the host 
		WriteNextResponseByte('\r');
	}
	#endif
	else if (Command == 'r')
    7384:	82 37       	cpi	r24, 0x72	; 114
    7386:	39 f4       	brne	.+14     	; 0x7396 <CDC_Task+0x14c>
	{
		WriteNextResponseByte(boot_lock_fuse_bits_get(GET_LOCK_BITS));
    7388:	89 e0       	ldi	r24, 0x09	; 9
    738a:	e1 e0       	ldi	r30, 0x01	; 1
    738c:	f0 e0       	ldi	r31, 0x00	; 0
    738e:	80 93 57 00 	sts	0x0057, r24
    7392:	84 91       	lpm	r24, Z+
    7394:	93 c1       	rjmp	.+806    	; 0x76bc <CDC_Task+0x472>
	}
	else if (Command == 'F')
    7396:	86 34       	cpi	r24, 0x46	; 70
    7398:	39 f4       	brne	.+14     	; 0x73a8 <CDC_Task+0x15e>
	{
		WriteNextResponseByte(boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS));
    739a:	89 e0       	ldi	r24, 0x09	; 9
    739c:	e0 e0       	ldi	r30, 0x00	; 0
    739e:	f0 e0       	ldi	r31, 0x00	; 0
    73a0:	80 93 57 00 	sts	0x0057, r24
    73a4:	84 91       	lpm	r24, Z+
    73a6:	8a c1       	rjmp	.+788    	; 0x76bc <CDC_Task+0x472>
	}
	else if (Command == 'N')
    73a8:	8e 34       	cpi	r24, 0x4E	; 78
    73aa:	39 f4       	brne	.+14     	; 0x73ba <CDC_Task+0x170>
	{
		WriteNextResponseByte(boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS));
    73ac:	89 e0       	ldi	r24, 0x09	; 9
    73ae:	e3 e0       	ldi	r30, 0x03	; 3
    73b0:	f0 e0       	ldi	r31, 0x00	; 0
    73b2:	80 93 57 00 	sts	0x0057, r24
    73b6:	84 91       	lpm	r24, Z+
    73b8:	81 c1       	rjmp	.+770    	; 0x76bc <CDC_Task+0x472>
	}
	else if (Command == 'Q')
    73ba:	81 35       	cpi	r24, 0x51	; 81
    73bc:	39 f4       	brne	.+14     	; 0x73cc <CDC_Task+0x182>
	{
		WriteNextResponseByte(boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS));
    73be:	89 e0       	ldi	r24, 0x09	; 9
    73c0:	e2 e0       	ldi	r30, 0x02	; 2
    73c2:	f0 e0       	ldi	r31, 0x00	; 0
    73c4:	80 93 57 00 	sts	0x0057, r24
    73c8:	84 91       	lpm	r24, Z+
    73ca:	78 c1       	rjmp	.+752    	; 0x76bc <CDC_Task+0x472>
	}
	#if !defined(NO_BLOCK_SUPPORT)
	else if (Command == 'b')
    73cc:	82 36       	cpi	r24, 0x62	; 98
    73ce:	31 f4       	brne	.+12     	; 0x73dc <CDC_Task+0x192>
	{
		WriteNextResponseByte('Y');
    73d0:	89 e5       	ldi	r24, 0x59	; 89
    73d2:	1a df       	rcall	.-460    	; 0x7208 <WriteNextResponseByte>

		// Send block size to the host 
		WriteNextResponseByte(SPM_PAGESIZE >> 8);
    73d4:	80 e0       	ldi	r24, 0x00	; 0
    73d6:	18 df       	rcall	.-464    	; 0x7208 <WriteNextResponseByte>
		WriteNextResponseByte(SPM_PAGESIZE & 0xFF);
    73d8:	80 e8       	ldi	r24, 0x80	; 128
    73da:	70 c1       	rjmp	.+736    	; 0x76bc <CDC_Task+0x472>
	}
	else if ((Command == 'B') || (Command == 'g'))
    73dc:	82 34       	cpi	r24, 0x42	; 66
    73de:	19 f0       	breq	.+6      	; 0x73e6 <CDC_Task+0x19c>
    73e0:	87 36       	cpi	r24, 0x67	; 103
    73e2:	09 f0       	breq	.+2      	; 0x73e6 <CDC_Task+0x19c>
    73e4:	d3 c0       	rjmp	.+422    	; 0x758c <CDC_Task+0x342>
	{
		// Keep resetting the timeout counter if we're receiving self-programming instructions
		Timeout = 0;
    73e6:	10 92 ad 01 	sts	0x01AD, r1
    73ea:	10 92 ac 01 	sts	0x01AC, r1
	char     MemoryType;

	bool     HighByte = false;
	uint8_t  LowByte  = 0;

	BlockSize  = (FetchNextCommandByte() << 8);
    73ee:	f4 de       	rcall	.-536    	; 0x71d8 <FetchNextCommandByte>
    73f0:	08 2f       	mov	r16, r24
	BlockSize |=  FetchNextCommandByte();
    73f2:	f2 de       	rcall	.-540    	; 0x71d8 <FetchNextCommandByte>
    73f4:	f8 2e       	mov	r15, r24

	MemoryType =  FetchNextCommandByte();
    73f6:	f0 de       	rcall	.-544    	; 0x71d8 <FetchNextCommandByte>
    73f8:	68 2e       	mov	r6, r24

	if ((MemoryType != 'E') && (MemoryType != 'F'))
    73fa:	85 54       	subi	r24, 0x45	; 69
    73fc:	82 30       	cpi	r24, 0x02	; 2
    73fe:	08 f0       	brcs	.+2      	; 0x7402 <CDC_Task+0x1b8>
    7400:	5c c1       	rjmp	.+696    	; 0x76ba <CDC_Task+0x470>
	char     MemoryType;

	bool     HighByte = false;
	uint8_t  LowByte  = 0;

	BlockSize  = (FetchNextCommandByte() << 8);
    7402:	90 2f       	mov	r25, r16
    7404:	80 e0       	ldi	r24, 0x00	; 0
	BlockSize |=  FetchNextCommandByte();
    7406:	8f 2c       	mov	r8, r15
    7408:	99 24       	eor	r9, r9
    740a:	88 2a       	or	r8, r24
    740c:	99 2a       	or	r9, r25
		return;
	}

	/* Disable timer 1 interrupt - can't afford to process nonessential interrupts
	 * while doing SPM tasks */
	TIMSK1 = 0;
    740e:	10 92 6f 00 	sts	0x006F, r1
    7412:	a0 90 ae 01 	lds	r10, 0x01AE
    7416:	b0 90 af 01 	lds	r11, 0x01AF
    741a:	c0 90 b0 01 	lds	r12, 0x01B0
    741e:	d0 90 b1 01 	lds	r13, 0x01B1

	/* Check if command is to read memory */
	if (Command == 'g')
    7422:	17 36       	cpi	r17, 0x67	; 103
    7424:	09 f0       	breq	.+2      	; 0x7428 <CDC_Task+0x1de>
    7426:	44 c0       	rjmp	.+136    	; 0x74b0 <CDC_Task+0x266>
	{		
		/* Re-enable RWW section */
		boot_rww_enable();
    7428:	81 e1       	ldi	r24, 0x11	; 17
    742a:	80 93 57 00 	sts	0x0057, r24
    742e:	e8 95       	spm
    7430:	86 01       	movw	r16, r12
    7432:	75 01       	movw	r14, r10
    7434:	dd 24       	eor	r13, r13

				/* If both bytes in current word have been read, increment the address counter */
				if (HighByte)
				  CurrAddress += 2;

				HighByte = !HighByte;
    7436:	cc 24       	eor	r12, r12
    7438:	c3 94       	inc	r12
    743a:	2e c0       	rjmp	.+92     	; 0x7498 <CDC_Task+0x24e>
		/* Re-enable RWW section */
		boot_rww_enable();

		while (BlockSize--)
		{
			if (MemoryType == 'F')
    743c:	b6 e4       	ldi	r27, 0x46	; 70
    743e:	6b 16       	cp	r6, r27
    7440:	99 f4       	brne	.+38     	; 0x7468 <CDC_Task+0x21e>
			{
				/* Read the next FLASH byte from the current FLASH page */
				#if (FLASHEND > 0xFFFF)
				WriteNextResponseByte(pgm_read_byte_far(CurrAddress | HighByte));
				#else
				WriteNextResponseByte(pgm_read_byte(CurrAddress | HighByte));
    7442:	ed 2d       	mov	r30, r13
    7444:	f0 e0       	ldi	r31, 0x00	; 0
    7446:	ee 29       	or	r30, r14
    7448:	ff 29       	or	r31, r15
    744a:	e4 91       	lpm	r30, Z+
    744c:	8e 2f       	mov	r24, r30
    744e:	dc de       	rcall	.-584    	; 0x7208 <WriteNextResponseByte>
				#endif

				/* If both bytes in current word have been read, increment the address counter */
				if (HighByte)
    7450:	dd 20       	and	r13, r13
    7452:	41 f0       	breq	.+16     	; 0x7464 <CDC_Task+0x21a>
				  CurrAddress += 2;
    7454:	82 e0       	ldi	r24, 0x02	; 2
    7456:	90 e0       	ldi	r25, 0x00	; 0
    7458:	a0 e0       	ldi	r26, 0x00	; 0
    745a:	b0 e0       	ldi	r27, 0x00	; 0
    745c:	e8 0e       	add	r14, r24
    745e:	f9 1e       	adc	r15, r25
    7460:	0a 1f       	adc	r16, r26
    7462:	1b 1f       	adc	r17, r27

				HighByte = !HighByte;
    7464:	dc 24       	eor	r13, r12
    7466:	15 c0       	rjmp	.+42     	; 0x7492 <CDC_Task+0x248>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7468:	f9 99       	sbic	0x1f, 1	; 31
    746a:	fe cf       	rjmp	.-4      	; 0x7468 <CDC_Task+0x21e>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    746c:	d8 01       	movw	r26, r16
    746e:	c7 01       	movw	r24, r14
    7470:	b6 95       	lsr	r27
    7472:	a7 95       	ror	r26
    7474:	97 95       	ror	r25
    7476:	87 95       	ror	r24
    7478:	92 bd       	out	0x22, r25	; 34
    747a:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    747c:	f8 9a       	sbi	0x1f, 0	; 31
    747e:	80 b5       	in	r24, 0x20	; 32
			}
			else
			{
				/* Read the next EEPROM byte into the endpoint */
				WriteNextResponseByte(eeprom_read_byte((uint8_t*)(intptr_t)(CurrAddress >> 1)));
    7480:	c3 de       	rcall	.-634    	; 0x7208 <WriteNextResponseByte>

				/* Increment the address counter after use */
				CurrAddress += 2;
    7482:	82 e0       	ldi	r24, 0x02	; 2
    7484:	90 e0       	ldi	r25, 0x00	; 0
    7486:	a0 e0       	ldi	r26, 0x00	; 0
    7488:	b0 e0       	ldi	r27, 0x00	; 0
    748a:	e8 0e       	add	r14, r24
    748c:	f9 1e       	adc	r15, r25
    748e:	0a 1f       	adc	r16, r26
    7490:	1b 1f       	adc	r17, r27
    7492:	08 94       	sec
    7494:	81 08       	sbc	r8, r1
    7496:	91 08       	sbc	r9, r1
	if (Command == 'g')
	{		
		/* Re-enable RWW section */
		boot_rww_enable();

		while (BlockSize--)
    7498:	81 14       	cp	r8, r1
    749a:	91 04       	cpc	r9, r1
    749c:	79 f6       	brne	.-98     	; 0x743c <CDC_Task+0x1f2>
    749e:	e0 92 ae 01 	sts	0x01AE, r14
    74a2:	f0 92 af 01 	sts	0x01AF, r15
    74a6:	00 93 b0 01 	sts	0x01B0, r16
    74aa:	10 93 b1 01 	sts	0x01B1, r17
    74ae:	6a c0       	rjmp	.+212    	; 0x7584 <CDC_Task+0x33a>
	}
	else
	{
		uint32_t PageStartAddress = CurrAddress;

		if (MemoryType == 'F')
    74b0:	96 e4       	ldi	r25, 0x46	; 70
    74b2:	69 16       	cp	r6, r25
    74b4:	09 f0       	breq	.+2      	; 0x74b8 <CDC_Task+0x26e>
    74b6:	47 c0       	rjmp	.+142    	; 0x7546 <CDC_Task+0x2fc>
		{
			boot_page_erase(PageStartAddress);
    74b8:	83 e0       	ldi	r24, 0x03	; 3
    74ba:	f5 01       	movw	r30, r10
    74bc:	80 93 57 00 	sts	0x0057, r24
    74c0:	e8 95       	spm
			boot_spm_busy_wait();
    74c2:	07 b6       	in	r0, 0x37	; 55
    74c4:	00 fc       	sbrc	r0, 0
    74c6:	fd cf       	rjmp	.-6      	; 0x74c2 <CDC_Task+0x278>
    74c8:	3e c0       	rjmp	.+124    	; 0x7546 <CDC_Task+0x2fc>
		}

		while (BlockSize--)
		{
			if (MemoryType == 'F')
    74ca:	f6 e4       	ldi	r31, 0x46	; 70
    74cc:	6f 16       	cp	r6, r31
    74ce:	e1 f4       	brne	.+56     	; 0x7508 <CDC_Task+0x2be>
			{
				/* If both bytes in current word have been written, increment the address counter */
				if (HighByte)
    74d0:	77 20       	and	r7, r7
    74d2:	b1 f0       	breq	.+44     	; 0x7500 <CDC_Task+0x2b6>
				{
					/* Write the next FLASH word to the current FLASH page */
					boot_page_fill(CurrAddress, ((FetchNextCommandByte() << 8) | LowByte));
    74d4:	81 de       	rcall	.-766    	; 0x71d8 <FetchNextCommandByte>
    74d6:	d8 2f       	mov	r29, r24
    74d8:	c0 e0       	ldi	r28, 0x00	; 0
    74da:	85 2d       	mov	r24, r5
    74dc:	90 e0       	ldi	r25, 0x00	; 0
    74de:	8c 2b       	or	r24, r28
    74e0:	9d 2b       	or	r25, r29
    74e2:	f7 01       	movw	r30, r14
    74e4:	0c 01       	movw	r0, r24
    74e6:	40 92 57 00 	sts	0x0057, r4
    74ea:	e8 95       	spm
    74ec:	11 24       	eor	r1, r1

					/* Increment the address counter after use */
					CurrAddress += 2;
    74ee:	82 e0       	ldi	r24, 0x02	; 2
    74f0:	90 e0       	ldi	r25, 0x00	; 0
    74f2:	a0 e0       	ldi	r26, 0x00	; 0
    74f4:	b0 e0       	ldi	r27, 0x00	; 0
    74f6:	e8 0e       	add	r14, r24
    74f8:	f9 1e       	adc	r15, r25
    74fa:	0a 1f       	adc	r16, r26
    74fc:	1b 1f       	adc	r17, r27
    74fe:	02 c0       	rjmp	.+4      	; 0x7504 <CDC_Task+0x2ba>
				}
				else
				{
					LowByte = FetchNextCommandByte();
    7500:	6b de       	rcall	.-810    	; 0x71d8 <FetchNextCommandByte>
    7502:	58 2e       	mov	r5, r24
				}
				
				HighByte = !HighByte;
    7504:	74 24       	eor	r7, r4
    7506:	1b c0       	rjmp	.+54     	; 0x753e <CDC_Task+0x2f4>
			}
			else
			{
				/* Write the next EEPROM byte from the endpoint */
				eeprom_write_byte((uint8_t*)((intptr_t)(CurrAddress >> 1)), FetchNextCommandByte());
    7508:	67 de       	rcall	.-818    	; 0x71d8 <FetchNextCommandByte>
    750a:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    750c:	f9 99       	sbic	0x1f, 1	; 31
    750e:	fe cf       	rjmp	.-4      	; 0x750c <CDC_Task+0x2c2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    7510:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    7512:	d8 01       	movw	r26, r16
    7514:	c7 01       	movw	r24, r14
    7516:	b6 95       	lsr	r27
    7518:	a7 95       	ror	r26
    751a:	97 95       	ror	r25
    751c:	87 95       	ror	r24
    751e:	92 bd       	out	0x22, r25	; 34
    7520:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    7522:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    7524:	0f b6       	in	r0, 0x3f	; 63
    7526:	f8 94       	cli
    7528:	fa 9a       	sbi	0x1f, 2	; 31
    752a:	f9 9a       	sbi	0x1f, 1	; 31
    752c:	0f be       	out	0x3f, r0	; 63

				/* Increment the address counter after use */
				CurrAddress += 2;
    752e:	82 e0       	ldi	r24, 0x02	; 2
    7530:	90 e0       	ldi	r25, 0x00	; 0
    7532:	a0 e0       	ldi	r26, 0x00	; 0
    7534:	b0 e0       	ldi	r27, 0x00	; 0
    7536:	e8 0e       	add	r14, r24
    7538:	f9 1e       	adc	r15, r25
    753a:	0a 1f       	adc	r16, r26
    753c:	1b 1f       	adc	r17, r27
    753e:	08 94       	sec
    7540:	81 08       	sbc	r8, r1
    7542:	91 08       	sbc	r9, r1
    7544:	06 c0       	rjmp	.+12     	; 0x7552 <CDC_Task+0x308>
    7546:	86 01       	movw	r16, r12
    7548:	75 01       	movw	r14, r10
    754a:	55 24       	eor	r5, r5
    754c:	77 24       	eor	r7, r7
				else
				{
					LowByte = FetchNextCommandByte();
				}
				
				HighByte = !HighByte;
    754e:	44 24       	eor	r4, r4
    7550:	43 94       	inc	r4
		{
			boot_page_erase(PageStartAddress);
			boot_spm_busy_wait();
		}

		while (BlockSize--)
    7552:	81 14       	cp	r8, r1
    7554:	91 04       	cpc	r9, r1
    7556:	09 f0       	breq	.+2      	; 0x755a <CDC_Task+0x310>
    7558:	b8 cf       	rjmp	.-144    	; 0x74ca <CDC_Task+0x280>
    755a:	e0 92 ae 01 	sts	0x01AE, r14
    755e:	f0 92 af 01 	sts	0x01AF, r15
    7562:	00 93 b0 01 	sts	0x01B0, r16
    7566:	10 93 b1 01 	sts	0x01B1, r17
				CurrAddress += 2;
			}
		}

		/* If in FLASH programming mode, commit the page after writing */
		if (MemoryType == 'F')
    756a:	96 e4       	ldi	r25, 0x46	; 70
    756c:	69 16       	cp	r6, r25
    756e:	41 f4       	brne	.+16     	; 0x7580 <CDC_Task+0x336>
		{
			/* Commit the flash page to memory */
			boot_page_write(PageStartAddress);
    7570:	85 e0       	ldi	r24, 0x05	; 5
    7572:	f5 01       	movw	r30, r10
    7574:	80 93 57 00 	sts	0x0057, r24
    7578:	e8 95       	spm

			/* Wait until write operation has completed */
			boot_spm_busy_wait();
    757a:	07 b6       	in	r0, 0x37	; 55
    757c:	00 fc       	sbrc	r0, 0
    757e:	fd cf       	rjmp	.-6      	; 0x757a <CDC_Task+0x330>
		}

		/* Send response byte back to the host */
		WriteNextResponseByte('\r');
    7580:	8d e0       	ldi	r24, 0x0D	; 13
    7582:	42 de       	rcall	.-892    	; 0x7208 <WriteNextResponseByte>
	}

	/* Re-enable timer 1 interrupt disabled earlier in this routine */	
	TIMSK1 = (1 << OCIE1A);
    7584:	82 e0       	ldi	r24, 0x02	; 2
    7586:	80 93 6f 00 	sts	0x006F, r24
    758a:	99 c0       	rjmp	.+306    	; 0x76be <CDC_Task+0x474>
		// Delegate the block write/read to a separate function for clarity 
		ReadWriteMemoryBlock(Command);
	}
	#endif
	#if !defined(NO_FLASH_BYTE_SUPPORT)
	else if (Command == 'C')
    758c:	83 34       	cpi	r24, 0x43	; 67
    758e:	71 f4       	brne	.+28     	; 0x75ac <CDC_Task+0x362>
	{
		// Write the high byte to the current flash page
		boot_page_fill(CurrAddress, FetchNextCommandByte());
    7590:	00 91 ae 01 	lds	r16, 0x01AE
    7594:	10 91 af 01 	lds	r17, 0x01AF
    7598:	1f de       	rcall	.-962    	; 0x71d8 <FetchNextCommandByte>
    759a:	90 e0       	ldi	r25, 0x00	; 0
    759c:	21 e0       	ldi	r18, 0x01	; 1
    759e:	f8 01       	movw	r30, r16
    75a0:	0c 01       	movw	r0, r24
    75a2:	20 93 57 00 	sts	0x0057, r18
    75a6:	e8 95       	spm
    75a8:	11 24       	eor	r1, r1
    75aa:	86 ce       	rjmp	.-756    	; 0x72b8 <CDC_Task+0x6e>

		// Send confirmation byte back to the host 
		WriteNextResponseByte('\r');
	}
	else if (Command == 'c')
    75ac:	83 36       	cpi	r24, 0x63	; 99
    75ae:	99 f4       	brne	.+38     	; 0x75d6 <CDC_Task+0x38c>
	{
		// Write the low byte to the current flash page 
		boot_page_fill(CurrAddress | 0x01, FetchNextCommandByte());
    75b0:	e0 90 ae 01 	lds	r14, 0x01AE
    75b4:	f0 90 af 01 	lds	r15, 0x01AF
    75b8:	00 91 b0 01 	lds	r16, 0x01B0
    75bc:	10 91 b1 01 	lds	r17, 0x01B1
    75c0:	0b de       	rcall	.-1002   	; 0x71d8 <FetchNextCommandByte>
    75c2:	f7 01       	movw	r30, r14
    75c4:	e1 60       	ori	r30, 0x01	; 1
    75c6:	90 e0       	ldi	r25, 0x00	; 0
    75c8:	21 e0       	ldi	r18, 0x01	; 1
    75ca:	0c 01       	movw	r0, r24
    75cc:	20 93 57 00 	sts	0x0057, r18
    75d0:	e8 95       	spm
    75d2:	11 24       	eor	r1, r1
    75d4:	37 c0       	rjmp	.+110    	; 0x7644 <CDC_Task+0x3fa>
		CurrAddress += 2;

		// Send confirmation byte back to the host 
		WriteNextResponseByte('\r');
	}
	else if (Command == 'm')
    75d6:	8d 36       	cpi	r24, 0x6D	; 109
    75d8:	61 f4       	brne	.+24     	; 0x75f2 <CDC_Task+0x3a8>
	{
		// Commit the flash page to memory
		boot_page_write(CurrAddress);
    75da:	e0 91 ae 01 	lds	r30, 0x01AE
    75de:	f0 91 af 01 	lds	r31, 0x01AF
    75e2:	85 e0       	ldi	r24, 0x05	; 5
    75e4:	80 93 57 00 	sts	0x0057, r24
    75e8:	e8 95       	spm

		// Wait until write operation has completed 
		boot_spm_busy_wait();
    75ea:	07 b6       	in	r0, 0x37	; 55
    75ec:	00 fc       	sbrc	r0, 0
    75ee:	fd cf       	rjmp	.-6      	; 0x75ea <CDC_Task+0x3a0>
    75f0:	63 ce       	rjmp	.-826    	; 0x72b8 <CDC_Task+0x6e>

		// Send confirmation byte back to the host 
		WriteNextResponseByte('\r');
	}
	else if (Command == 'R')
    75f2:	82 35       	cpi	r24, 0x52	; 82
    75f4:	51 f4       	brne	.+20     	; 0x760a <CDC_Task+0x3c0>
	{
		#if (FLASHEND > 0xFFFF)
		uint16_t ProgramWord = pgm_read_word_far(CurrAddress);
		#else
		uint16_t ProgramWord = pgm_read_word(CurrAddress);
    75f6:	e0 91 ae 01 	lds	r30, 0x01AE
    75fa:	f0 91 af 01 	lds	r31, 0x01AF
    75fe:	05 91       	lpm	r16, Z+
    7600:	14 91       	lpm	r17, Z+
		#endif

		WriteNextResponseByte(ProgramWord >> 8);
    7602:	81 2f       	mov	r24, r17
    7604:	01 de       	rcall	.-1022   	; 0x7208 <WriteNextResponseByte>
		WriteNextResponseByte(ProgramWord & 0xFF);
    7606:	80 2f       	mov	r24, r16
    7608:	59 c0       	rjmp	.+178    	; 0x76bc <CDC_Task+0x472>
	}
	#endif
	#if !defined(NO_EEPROM_BYTE_SUPPORT)
	else if (Command == 'D')
    760a:	84 34       	cpi	r24, 0x44	; 68
    760c:	61 f5       	brne	.+88     	; 0x7666 <CDC_Task+0x41c>
	{
		// Read the byte from the endpoint and write it to the EEPROM 
		eeprom_write_byte((uint8_t*)((intptr_t)(CurrAddress >> 1)), FetchNextCommandByte());
    760e:	e0 90 ae 01 	lds	r14, 0x01AE
    7612:	f0 90 af 01 	lds	r15, 0x01AF
    7616:	00 91 b0 01 	lds	r16, 0x01B0
    761a:	10 91 b1 01 	lds	r17, 0x01B1
    761e:	dc dd       	rcall	.-1096   	; 0x71d8 <FetchNextCommandByte>
    7620:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    7622:	f9 99       	sbic	0x1f, 1	; 31
    7624:	fe cf       	rjmp	.-4      	; 0x7622 <CDC_Task+0x3d8>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    7626:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    7628:	d8 01       	movw	r26, r16
    762a:	c7 01       	movw	r24, r14
    762c:	b6 95       	lsr	r27
    762e:	a7 95       	ror	r26
    7630:	97 95       	ror	r25
    7632:	87 95       	ror	r24
    7634:	92 bd       	out	0x22, r25	; 34
    7636:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    7638:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    763a:	0f b6       	in	r0, 0x3f	; 63
    763c:	f8 94       	cli
    763e:	fa 9a       	sbi	0x1f, 2	; 31
    7640:	f9 9a       	sbi	0x1f, 1	; 31
    7642:	0f be       	out	0x3f, r0	; 63

		// Increment the address after use
		CurrAddress += 2;
    7644:	82 e0       	ldi	r24, 0x02	; 2
    7646:	90 e0       	ldi	r25, 0x00	; 0
    7648:	a0 e0       	ldi	r26, 0x00	; 0
    764a:	b0 e0       	ldi	r27, 0x00	; 0
    764c:	e8 0e       	add	r14, r24
    764e:	f9 1e       	adc	r15, r25
    7650:	0a 1f       	adc	r16, r26
    7652:	1b 1f       	adc	r17, r27
    7654:	e0 92 ae 01 	sts	0x01AE, r14
    7658:	f0 92 af 01 	sts	0x01AF, r15
    765c:	00 93 b0 01 	sts	0x01B0, r16
    7660:	10 93 b1 01 	sts	0x01B1, r17
    7664:	29 ce       	rjmp	.-942    	; 0x72b8 <CDC_Task+0x6e>

		// Send confirmation byte back to the host 
		WriteNextResponseByte('\r');
	}
	else if (Command == 'd')
    7666:	84 36       	cpi	r24, 0x64	; 100
    7668:	31 f5       	brne	.+76     	; 0x76b6 <CDC_Task+0x46c>
	{
		// Read the EEPROM byte and write it to the endpoint 
		WriteNextResponseByte(eeprom_read_byte((uint8_t*)((intptr_t)(CurrAddress >> 1))));
    766a:	e0 90 ae 01 	lds	r14, 0x01AE
    766e:	f0 90 af 01 	lds	r15, 0x01AF
    7672:	00 91 b0 01 	lds	r16, 0x01B0
    7676:	10 91 b1 01 	lds	r17, 0x01B1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    767a:	f9 99       	sbic	0x1f, 1	; 31
    767c:	fe cf       	rjmp	.-4      	; 0x767a <CDC_Task+0x430>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    767e:	d8 01       	movw	r26, r16
    7680:	c7 01       	movw	r24, r14
    7682:	b6 95       	lsr	r27
    7684:	a7 95       	ror	r26
    7686:	97 95       	ror	r25
    7688:	87 95       	ror	r24
    768a:	92 bd       	out	0x22, r25	; 34
    768c:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    768e:	f8 9a       	sbi	0x1f, 0	; 31
    7690:	80 b5       	in	r24, 0x20	; 32
    7692:	ba dd       	rcall	.-1164   	; 0x7208 <WriteNextResponseByte>

		// Increment the address after use 
		CurrAddress += 2;
    7694:	82 e0       	ldi	r24, 0x02	; 2
    7696:	90 e0       	ldi	r25, 0x00	; 0
    7698:	a0 e0       	ldi	r26, 0x00	; 0
    769a:	b0 e0       	ldi	r27, 0x00	; 0
    769c:	e8 0e       	add	r14, r24
    769e:	f9 1e       	adc	r15, r25
    76a0:	0a 1f       	adc	r16, r26
    76a2:	1b 1f       	adc	r17, r27
    76a4:	e0 92 ae 01 	sts	0x01AE, r14
    76a8:	f0 92 af 01 	sts	0x01AF, r15
    76ac:	00 93 b0 01 	sts	0x01B0, r16
    76b0:	10 93 b1 01 	sts	0x01B1, r17
    76b4:	04 c0       	rjmp	.+8      	; 0x76be <CDC_Task+0x474>
	}
	#endif
	else if (Command != 27)
    76b6:	8b 31       	cpi	r24, 0x1B	; 27
    76b8:	11 f0       	breq	.+4      	; 0x76be <CDC_Task+0x474>
	{
		// Unknown (non-sync) command, return fail code 
		WriteNextResponseByte('?');
    76ba:	8f e3       	ldi	r24, 0x3F	; 63
    76bc:	a5 dd       	rcall	.-1206   	; 0x7208 <WriteNextResponseByte>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    76be:	83 e0       	ldi	r24, 0x03	; 3
    76c0:	80 93 e9 00 	sts	0x00E9, r24
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    76c4:	90 91 e8 00 	lds	r25, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    76c8:	80 91 e8 00 	lds	r24, 0x00E8
    76cc:	8e 77       	andi	r24, 0x7E	; 126
    76ce:	80 93 e8 00 	sts	0x00E8, r24

	/* Send the endpoint data to the host */
	Endpoint_ClearIN();

	/* If a full endpoint's worth of data was sent, we need to send an empty packet afterwards to signal end of transfer */
	if (IsEndpointFull)
    76d2:	95 ff       	sbrs	r25, 5
    76d4:	04 c0       	rjmp	.+8      	; 0x76de <CDC_Task+0x494>
    76d6:	10 c0       	rjmp	.+32     	; 0x76f8 <CDC_Task+0x4ae>
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    76d8:	8e b3       	in	r24, 0x1e	; 30
    76da:	88 23       	and	r24, r24
    76dc:	c9 f0       	breq	.+50     	; 0x7710 <CDC_Task+0x4c6>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    76de:	80 91 e8 00 	lds	r24, 0x00E8
	Endpoint_ClearIN();

	/* If a full endpoint's worth of data was sent, we need to send an empty packet afterwards to signal end of transfer */
	if (IsEndpointFull)
	{
		while (!(Endpoint_IsINReady()))
    76e2:	80 ff       	sbrs	r24, 0
    76e4:	f9 cf       	rjmp	.-14     	; 0x76d8 <CDC_Task+0x48e>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    76e6:	80 91 e8 00 	lds	r24, 0x00E8
    76ea:	8e 77       	andi	r24, 0x7E	; 126
    76ec:	80 93 e8 00 	sts	0x00E8, r24
    76f0:	03 c0       	rjmp	.+6      	; 0x76f8 <CDC_Task+0x4ae>
	}

	/* Wait until the data has been sent to the host */
	while (!(Endpoint_IsINReady()))
	{
		if (USB_DeviceState == DEVICE_STATE_Unattached)
    76f2:	8e b3       	in	r24, 0x1e	; 30
    76f4:	88 23       	and	r24, r24
    76f6:	61 f0       	breq	.+24     	; 0x7710 <CDC_Task+0x4c6>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    76f8:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearIN();
	}

	/* Wait until the data has been sent to the host */
	while (!(Endpoint_IsINReady()))
    76fc:	80 ff       	sbrs	r24, 0
    76fe:	f9 cf       	rjmp	.-14     	; 0x76f2 <CDC_Task+0x4a8>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7700:	84 e0       	ldi	r24, 0x04	; 4
    7702:	80 93 e9 00 	sts	0x00E9, r24
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    7706:	80 91 e8 00 	lds	r24, 0x00E8
    770a:	8b 77       	andi	r24, 0x7B	; 123
    770c:	80 93 e8 00 	sts	0x00E8, r24
	/* Select the OUT endpoint */
	Endpoint_SelectEndpoint(CDC_RX_EPNUM);

	/* Acknowledge the command from the host */
	Endpoint_ClearOUT();
}
    7710:	df 91       	pop	r29
    7712:	cf 91       	pop	r28
    7714:	1f 91       	pop	r17
    7716:	0f 91       	pop	r16
    7718:	ff 90       	pop	r15
    771a:	ef 90       	pop	r14
    771c:	df 90       	pop	r13
    771e:	cf 90       	pop	r12
    7720:	bf 90       	pop	r11
    7722:	af 90       	pop	r10
    7724:	9f 90       	pop	r9
    7726:	8f 90       	pop	r8
    7728:	7f 90       	pop	r7
    772a:	6f 90       	pop	r6
    772c:	5f 90       	pop	r5
    772e:	4f 90       	pop	r4
    7730:	08 95       	ret

00007732 <EVENT_USB_Device_ControlRequest>:
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
{
	/* Ignore any requests that aren't directed to the CDC interface */
	if ((USB_ControlRequest.bmRequestType & (CONTROL_REQTYPE_TYPE | CONTROL_REQTYPE_RECIPIENT)) !=
    7732:	90 91 b6 01 	lds	r25, 0x01B6
    7736:	89 2f       	mov	r24, r25
    7738:	8f 77       	andi	r24, 0x7F	; 127
    773a:	81 32       	cpi	r24, 0x21	; 33
    773c:	49 f5       	brne	.+82     	; 0x7790 <EVENT_USB_Device_ControlRequest+0x5e>
	{
		return;
	}

	/* Process CDC specific control requests */
	switch (USB_ControlRequest.bRequest)
    773e:	80 91 b7 01 	lds	r24, 0x01B7
    7742:	80 32       	cpi	r24, 0x20	; 32
    7744:	a1 f0       	breq	.+40     	; 0x776e <EVENT_USB_Device_ControlRequest+0x3c>
    7746:	81 32       	cpi	r24, 0x21	; 33
    7748:	19 f5       	brne	.+70     	; 0x7790 <EVENT_USB_Device_ControlRequest+0x5e>
	{
		case CDC_REQ_GetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    774a:	91 3a       	cpi	r25, 0xA1	; 161
    774c:	09 f5       	brne	.+66     	; 0x7790 <EVENT_USB_Device_ControlRequest+0x5e>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    774e:	80 91 e8 00 	lds	r24, 0x00E8
    7752:	87 7f       	andi	r24, 0xF7	; 247
    7754:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();

				/* Write the line coding data to the control endpoint */
				Endpoint_Write_Control_Stream_LE(&LineEncoding, sizeof(CDC_LineEncoding_t));
    7758:	8d e0       	ldi	r24, 0x0D	; 13
    775a:	91 e0       	ldi	r25, 0x01	; 1
    775c:	67 e0       	ldi	r22, 0x07	; 7
    775e:	70 e0       	ldi	r23, 0x00	; 0
    7760:	11 d2       	rcall	.+1058   	; 0x7b84 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    7762:	80 91 e8 00 	lds	r24, 0x00E8
    7766:	8b 77       	andi	r24, 0x7B	; 123
    7768:	80 93 e8 00 	sts	0x00E8, r24
    776c:	08 95       	ret
				Endpoint_ClearOUT();
			}

			break;
		case CDC_REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    776e:	91 32       	cpi	r25, 0x21	; 33
    7770:	79 f4       	brne	.+30     	; 0x7790 <EVENT_USB_Device_ControlRequest+0x5e>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7772:	80 91 e8 00 	lds	r24, 0x00E8
    7776:	87 7f       	andi	r24, 0xF7	; 247
    7778:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();

				/* Read the line coding data in from the host into the global struct */
				Endpoint_Read_Control_Stream_LE(&LineEncoding, sizeof(CDC_LineEncoding_t));
    777c:	8d e0       	ldi	r24, 0x0D	; 13
    777e:	91 e0       	ldi	r25, 0x01	; 1
    7780:	67 e0       	ldi	r22, 0x07	; 7
    7782:	70 e0       	ldi	r23, 0x00	; 0
    7784:	63 d2       	rcall	.+1222   	; 0x7c4c <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7786:	80 91 e8 00 	lds	r24, 0x00E8
    778a:	8e 77       	andi	r24, 0x7E	; 126
    778c:	80 93 e8 00 	sts	0x00E8, r24
    7790:	08 95       	ret

00007792 <EVENT_USB_Device_ConfigurationChanged>:
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    7792:	82 e0       	ldi	r24, 0x02	; 2
    7794:	61 ec       	ldi	r22, 0xC1	; 193
    7796:	42 e0       	ldi	r20, 0x02	; 2
    7798:	bb d0       	rcall	.+374    	; 0x7910 <Endpoint_ConfigureEndpoint_Prv>
	                           ENDPOINT_BANK_SINGLE);

	Endpoint_ConfigureEndpoint(CDC_RX_EPNUM, EP_TYPE_BULK,
	                           ENDPOINT_DIR_OUT, CDC_TXRX_EPSIZE,
	                           ENDPOINT_BANK_SINGLE);
}
    779a:	83 e0       	ldi	r24, 0x03	; 3
    779c:	61 e8       	ldi	r22, 0x81	; 129
    779e:	42 e1       	ldi	r20, 0x12	; 18
    77a0:	b7 d0       	rcall	.+366    	; 0x7910 <Endpoint_ConfigureEndpoint_Prv>
    77a2:	84 e0       	ldi	r24, 0x04	; 4
    77a4:	60 e8       	ldi	r22, 0x80	; 128
    77a6:	42 e1       	ldi	r20, 0x12	; 18
    77a8:	b3 c0       	rjmp	.+358    	; 0x7910 <Endpoint_ConfigureEndpoint_Prv>

000077aa <SetupHardware>:

/** Configures all hardware required for the bootloader. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
    77aa:	84 b7       	in	r24, 0x34	; 52
    77ac:	87 7f       	andi	r24, 0xF7	; 247
    77ae:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
    77b0:	88 e1       	ldi	r24, 0x18	; 24
    77b2:	0f b6       	in	r0, 0x3f	; 63
    77b4:	f8 94       	cli
    77b6:	80 93 60 00 	sts	0x0060, r24
    77ba:	10 92 60 00 	sts	0x0060, r1
    77be:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
    77c0:	20 e8       	ldi	r18, 0x80	; 128
    77c2:	80 e0       	ldi	r24, 0x00	; 0
    77c4:	90 e0       	ldi	r25, 0x00	; 0
    77c6:	0f b6       	in	r0, 0x3f	; 63
    77c8:	f8 94       	cli
    77ca:	20 93 61 00 	sts	0x0061, r18
    77ce:	80 93 61 00 	sts	0x0061, r24
    77d2:	0f be       	out	0x3f, r0	; 63

	/* Relocate the interrupt vector table to the bootloader section */
	MCUCR = (1 << IVCE);
    77d4:	81 e0       	ldi	r24, 0x01	; 1
    77d6:	85 bf       	out	0x35, r24	; 53
	MCUCR = (1 << IVSEL);
    77d8:	92 e0       	ldi	r25, 0x02	; 2
    77da:	95 bf       	out	0x35, r25	; 53
	
	LED_SETUP();
    77dc:	27 9a       	sbi	0x04, 7	; 4
    77de:	25 9a       	sbi	0x04, 5	; 4
    77e0:	26 9a       	sbi	0x04, 6	; 4
	CPU_PRESCALE(0); 
    77e2:	e1 e6       	ldi	r30, 0x61	; 97
    77e4:	f0 e0       	ldi	r31, 0x00	; 0
    77e6:	20 83       	st	Z, r18
    77e8:	10 82       	st	Z, r1
	L_LED_OFF();
    77ea:	85 b1       	in	r24, 0x05	; 5
    77ec:	8f 67       	ori	r24, 0x7F	; 127
    77ee:	85 b9       	out	0x05, r24	; 5
	TX_LED_OFF();
    77f0:	85 b1       	in	r24, 0x05	; 5
    77f2:	8f 6d       	ori	r24, 0xDF	; 223
    77f4:	85 b9       	out	0x05, r24	; 5
	RX_LED_OFF();
    77f6:	85 b1       	in	r24, 0x05	; 5
    77f8:	8f 6b       	ori	r24, 0xBF	; 191
    77fa:	85 b9       	out	0x05, r24	; 5
	 * With 16 MHz clock and 1/64 prescaler, timer 1 is clocked at 250 kHz
	 * Our chosen compare match generates an interrupt every 1 ms.
	 * This interrupt is disabled selectively when doing memory reading, erasing,
	 * or writing since SPM has tight timing requirements.
	 */ 
	OCR1AH = 0;
    77fc:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = 250;
    7800:	8a ef       	ldi	r24, 0xFA	; 250
    7802:	80 93 88 00 	sts	0x0088, r24
	TIMSK1 = (1 << OCIE1A);					// enable timer 1 output compare A match interrupt
    7806:	90 93 6f 00 	sts	0x006F, r25
	TCCR1B = ((1 << CS11) | (1 << CS10));	// 1/64 prescaler on timer 1 input
    780a:	83 e0       	ldi	r24, 0x03	; 3
    780c:	80 93 81 00 	sts	0x0081, r24

	/* Initialize USB Subsystem */
	USB_Init();
}
    7810:	f0 c0       	rjmp	.+480    	; 0x79f2 <USB_Init>

00007812 <main>:
 *  runs the bootloader processing routine until it times out or is instructed to exit.
 */
int main(void)
{
	/* Save the value of the boot key memory before it is overwritten */
	uint16_t bootKeyPtrVal = *bootKeyPtr;
    7812:	40 91 00 08 	lds	r20, 0x0800
    7816:	50 91 01 08 	lds	r21, 0x0801
	*bootKeyPtr = 0;
    781a:	10 92 01 08 	sts	0x0801, r1
    781e:	10 92 00 08 	sts	0x0800, r1

	/* Check the reason for the reset so we can act accordingly */
	uint8_t  mcusr_state = MCUSR;		// store the initial state of the Status register
    7822:	94 b7       	in	r25, 0x34	; 52
	MCUSR = 0;							// clear all reset flags	
    7824:	14 be       	out	0x34, r1	; 52

	/* Watchdog may be configured with a 15 ms period so must disable it before going any further */
	wdt_disable();
    7826:	88 e1       	ldi	r24, 0x18	; 24
    7828:	0f b6       	in	r0, 0x3f	; 63
    782a:	f8 94       	cli
    782c:	80 93 60 00 	sts	0x0060, r24
    7830:	10 92 60 00 	sts	0x0060, r1
    7834:	0f be       	out	0x3f, r0	; 63
	
	if (mcusr_state & (1<<EXTRF)) {
    7836:	29 2f       	mov	r18, r25
    7838:	30 e0       	ldi	r19, 0x00	; 0
    783a:	f9 01       	movw	r30, r18
    783c:	e2 70       	andi	r30, 0x02	; 2
    783e:	f0 70       	andi	r31, 0x00	; 0
    7840:	91 fd       	sbrc	r25, 1
    7842:	18 c0       	rjmp	.+48     	; 0x7874 <main+0x62>
		// External reset -  we should continue to self-programming mode.
	} else if ((mcusr_state & (1<<PORF)) && (pgm_read_word(0) != 0xFFFF)) {		
    7844:	90 ff       	sbrs	r25, 0
    7846:	05 c0       	rjmp	.+10     	; 0x7852 <main+0x40>
    7848:	85 91       	lpm	r24, Z+
    784a:	94 91       	lpm	r25, Z+
    784c:	8f 5f       	subi	r24, 0xFF	; 255
    784e:	9f 4f       	sbci	r25, 0xFF	; 255
    7850:	81 f4       	brne	.+32     	; 0x7872 <main+0x60>
		// After a power-on reset skip the bootloader and jump straight to sketch 
		// if one exists.	
		StartSketch();
	} else if ((mcusr_state & (1<<WDRF)) && (bootKeyPtrVal != bootKey) && (pgm_read_word(0) != 0xFFFF)) {	
    7852:	23 ff       	sbrs	r18, 3
    7854:	0f c0       	rjmp	.+30     	; 0x7874 <main+0x62>
    7856:	80 91 09 01 	lds	r24, 0x0109
    785a:	90 91 0a 01 	lds	r25, 0x010A
    785e:	48 17       	cp	r20, r24
    7860:	59 07       	cpc	r21, r25
    7862:	41 f0       	breq	.+16     	; 0x7874 <main+0x62>
    7864:	e0 e0       	ldi	r30, 0x00	; 0
    7866:	f0 e0       	ldi	r31, 0x00	; 0
    7868:	85 91       	lpm	r24, Z+
    786a:	94 91       	lpm	r25, Z+
    786c:	8f 5f       	subi	r24, 0xFF	; 255
    786e:	9f 4f       	sbci	r25, 0xFF	; 255
    7870:	09 f0       	breq	.+2      	; 0x7874 <main+0x62>
		// If it looks like an "accidental" watchdog reset then start the sketch.
		StartSketch();
    7872:	38 dc       	rcall	.-1936   	; 0x70e4 <StartSketch>
	}
	
	/* Setup hardware required for the bootloader */
	SetupHardware();
    7874:	9a df       	rcall	.-204    	; 0x77aa <SetupHardware>

	/* Enable global interrupts so that the USB stack can function */
	sei();
    7876:	78 94       	sei
	
	Timeout = 0;
    7878:	10 92 ad 01 	sts	0x01AD, r1
    787c:	10 92 ac 01 	sts	0x01AC, r1
    7880:	0c c0       	rjmp	.+24     	; 0x789a <main+0x88>
	
	while (RunBootloader)
	{
		CDC_Task();
    7882:	e3 dc       	rcall	.-1594   	; 0x724a <CDC_Task>
		USB_USBTask();
    7884:	36 d3       	rcall	.+1644   	; 0x7ef2 <USB_USBTask>
		/* Time out and start the sketch if one is present */
		if (Timeout > TIMEOUT_PERIOD)
    7886:	80 91 ac 01 	lds	r24, 0x01AC
    788a:	90 91 ad 01 	lds	r25, 0x01AD
    788e:	81 54       	subi	r24, 0x41	; 65
    7890:	9f 41       	sbci	r25, 0x1F	; 31
    7892:	10 f0       	brcs	.+4      	; 0x7898 <main+0x86>
			RunBootloader = false;
    7894:	10 92 14 01 	sts	0x0114, r1

		LEDPulse();
    7898:	3d dc       	rcall	.-1926   	; 0x7114 <LEDPulse>
	/* Enable global interrupts so that the USB stack can function */
	sei();
	
	Timeout = 0;
	
	while (RunBootloader)
    789a:	80 91 14 01 	lds	r24, 0x0114
    789e:	88 23       	and	r24, r24
    78a0:	81 f7       	brne	.-32     	; 0x7882 <main+0x70>
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    78a2:	80 91 e0 00 	lds	r24, 0x00E0
    78a6:	81 60       	ori	r24, 0x01	; 1
    78a8:	80 93 e0 00 	sts	0x00E0, r24

	/* Disconnect from the host - USB interface will be reset later along with the AVR */
	USB_Detach();

	/* Jump to beginning of application space to run the sketch - do not reset */	
	StartSketch();
    78ac:	1b dc       	rcall	.-1994   	; 0x70e4 <StartSketch>
}
    78ae:	80 e0       	ldi	r24, 0x00	; 0
    78b0:	90 e0       	ldi	r25, 0x00	; 0
    78b2:	08 95       	ret

000078b4 <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
    78b4:	fa 01       	movw	r30, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
    78b6:	92 30       	cpi	r25, 0x02	; 2
    78b8:	49 f0       	breq	.+18     	; 0x78cc <CALLBACK_USB_GetDescriptor+0x18>
    78ba:	93 30       	cpi	r25, 0x03	; 3
    78bc:	61 f0       	breq	.+24     	; 0x78d6 <CALLBACK_USB_GetDescriptor+0x22>
    78be:	91 30       	cpi	r25, 0x01	; 1
    78c0:	f9 f4       	brne	.+62     	; 0x7900 <CALLBACK_USB_GetDescriptor+0x4c>
    78c2:	85 e1       	ldi	r24, 0x15	; 21
    78c4:	91 e0       	ldi	r25, 0x01	; 1
    78c6:	22 e1       	ldi	r18, 0x12	; 18
    78c8:	30 e0       	ldi	r19, 0x00	; 0
    78ca:	1e c0       	rjmp	.+60     	; 0x7908 <CALLBACK_USB_GetDescriptor+0x54>
    78cc:	87 e2       	ldi	r24, 0x27	; 39
    78ce:	91 e0       	ldi	r25, 0x01	; 1
    78d0:	2e e3       	ldi	r18, 0x3E	; 62
    78d2:	30 e0       	ldi	r19, 0x00	; 0
    78d4:	19 c0       	rjmp	.+50     	; 0x7908 <CALLBACK_USB_GetDescriptor+0x54>
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			if (!(DescriptorNumber))
    78d6:	88 23       	and	r24, r24
    78d8:	29 f4       	brne	.+10     	; 0x78e4 <CALLBACK_USB_GetDescriptor+0x30>
    78da:	85 e6       	ldi	r24, 0x65	; 101
    78dc:	91 e0       	ldi	r25, 0x01	; 1
    78de:	24 e0       	ldi	r18, 0x04	; 4
    78e0:	30 e0       	ldi	r19, 0x00	; 0
    78e2:	12 c0       	rjmp	.+36     	; 0x7908 <CALLBACK_USB_GetDescriptor+0x54>
			{
				Address = &LanguageString;
				Size    = LanguageString.Header.Size;
			}
			else if (DescriptorNumber == DeviceDescriptor.ProductStrIndex) 
    78e4:	81 30       	cpi	r24, 0x01	; 1
    78e6:	29 f4       	brne	.+10     	; 0x78f2 <CALLBACK_USB_GetDescriptor+0x3e>
    78e8:	89 e6       	ldi	r24, 0x69	; 105
    78ea:	91 e0       	ldi	r25, 0x01	; 1
    78ec:	22 e2       	ldi	r18, 0x22	; 34
    78ee:	30 e0       	ldi	r19, 0x00	; 0
    78f0:	0b c0       	rjmp	.+22     	; 0x7908 <CALLBACK_USB_GetDescriptor+0x54>
			{
				Address = &ProductString;
				Size    = ProductString.Header.Size;
			} else if (DescriptorNumber == DeviceDescriptor.ManufacturerStrIndex)
    78f2:	82 30       	cpi	r24, 0x02	; 2
    78f4:	29 f4       	brne	.+10     	; 0x7900 <CALLBACK_USB_GetDescriptor+0x4c>
    78f6:	8d e8       	ldi	r24, 0x8D	; 141
    78f8:	91 e0       	ldi	r25, 0x01	; 1
    78fa:	28 e1       	ldi	r18, 0x18	; 24
    78fc:	30 e0       	ldi	r19, 0x00	; 0
    78fe:	04 c0       	rjmp	.+8      	; 0x7908 <CALLBACK_USB_GetDescriptor+0x54>
    7900:	80 e0       	ldi	r24, 0x00	; 0
    7902:	90 e0       	ldi	r25, 0x00	; 0
    7904:	20 e0       	ldi	r18, 0x00	; 0
    7906:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
    7908:	91 83       	std	Z+1, r25	; 0x01
    790a:	80 83       	st	Z, r24
	return Size;
}
    790c:	c9 01       	movw	r24, r18
    790e:	08 95       	ret

00007910 <Endpoint_ConfigureEndpoint_Prv>:
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7910:	80 93 e9 00 	sts	0x00E9, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    7914:	80 91 eb 00 	lds	r24, 0x00EB
    7918:	81 60       	ori	r24, 0x01	; 1
    791a:	80 93 eb 00 	sts	0x00EB, r24
{
#if defined(CONTROL_ONLY_DEVICE) || defined(ORDERED_EP_CONFIG)
	Endpoint_SelectEndpoint(Number);
	Endpoint_EnableEndpoint();

	UECFG1X = 0;
    791e:	10 92 ed 00 	sts	0x00ED, r1
	UECFG0X = UECFG0XData;
    7922:	60 93 ec 00 	sts	0x00EC, r22
	UECFG1X = UECFG1XData;
    7926:	40 93 ed 00 	sts	0x00ED, r20
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    792a:	80 91 ee 00 	lds	r24, 0x00EE
	}
	
	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    792e:	88 1f       	adc	r24, r24
    7930:	88 27       	eor	r24, r24
    7932:	88 1f       	adc	r24, r24
    7934:	08 95       	ret

00007936 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    7936:	80 91 b6 01 	lds	r24, 0x01B6
    793a:	88 23       	and	r24, r24
    793c:	8c f4       	brge	.+34     	; 0x7960 <Endpoint_ClearStatusStage+0x2a>
    793e:	03 c0       	rjmp	.+6      	; 0x7946 <Endpoint_ClearStatusStage+0x10>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    7940:	8e b3       	in	r24, 0x1e	; 30
    7942:	88 23       	and	r24, r24
    7944:	b1 f0       	breq	.+44     	; 0x7972 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7946:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    794a:	82 ff       	sbrs	r24, 2
    794c:	f9 cf       	rjmp	.-14     	; 0x7940 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    794e:	80 91 e8 00 	lds	r24, 0x00E8
    7952:	8b 77       	andi	r24, 0x7B	; 123
    7954:	80 93 e8 00 	sts	0x00E8, r24
    7958:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    795a:	8e b3       	in	r24, 0x1e	; 30
    795c:	88 23       	and	r24, r24
    795e:	49 f0       	breq	.+18     	; 0x7972 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    7960:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    7964:	80 ff       	sbrs	r24, 0
    7966:	f9 cf       	rjmp	.-14     	; 0x795a <Endpoint_ClearStatusStage+0x24>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7968:	80 91 e8 00 	lds	r24, 0x00E8
    796c:	8e 77       	andi	r24, 0x7E	; 126
    796e:	80 93 e8 00 	sts	0x00E8, r24
    7972:	08 95       	ret

00007974 <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    7974:	ef 92       	push	r14
    7976:	ff 92       	push	r15
    7978:	0f 93       	push	r16
    797a:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    797c:	45 d0       	rcall	.+138    	; 0x7a08 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    797e:	4c d0       	rcall	.+152    	; 0x7a18 <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    7980:	08 ed       	ldi	r16, 0xD8	; 216
    7982:	10 e0       	ldi	r17, 0x00	; 0
    7984:	f8 01       	movw	r30, r16
    7986:	80 81       	ld	r24, Z
    7988:	8f 77       	andi	r24, 0x7F	; 127
    798a:	80 83       	st	Z, r24
				USBCON |=  (1 << USBE);
    798c:	80 81       	ld	r24, Z
    798e:	80 68       	ori	r24, 0x80	; 128
    7990:	80 83       	st	Z, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    7992:	80 81       	ld	r24, Z
    7994:	8f 7d       	andi	r24, 0xDF	; 223
    7996:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    7998:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    799a:	1e ba       	out	0x1e, r1	; 30
	USB_Device_ConfigurationNumber  = 0;
    799c:	10 92 b4 01 	sts	0x01B4, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    79a0:	80 ee       	ldi	r24, 0xE0	; 224
    79a2:	e8 2e       	mov	r14, r24
    79a4:	f1 2c       	mov	r15, r1
    79a6:	f7 01       	movw	r30, r14
    79a8:	80 81       	ld	r24, Z
    79aa:	8b 7f       	andi	r24, 0xFB	; 251
    79ac:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    79ae:	f8 01       	movw	r30, r16
    79b0:	80 81       	ld	r24, Z
    79b2:	81 60       	ori	r24, 0x01	; 1
    79b4:	80 83       	st	Z, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    79b6:	80 e0       	ldi	r24, 0x00	; 0
    79b8:	60 e0       	ldi	r22, 0x00	; 0
    79ba:	42 e0       	ldi	r20, 0x02	; 2
    79bc:	a9 df       	rcall	.-174    	; 0x7910 <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    79be:	e1 ee       	ldi	r30, 0xE1	; 225
    79c0:	f0 e0       	ldi	r31, 0x00	; 0
    79c2:	80 81       	ld	r24, Z
    79c4:	8e 7f       	andi	r24, 0xFE	; 254
    79c6:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    79c8:	e2 ee       	ldi	r30, 0xE2	; 226
    79ca:	f0 e0       	ldi	r31, 0x00	; 0
    79cc:	80 81       	ld	r24, Z
    79ce:	81 60       	ori	r24, 0x01	; 1
    79d0:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    79d2:	80 81       	ld	r24, Z
    79d4:	88 60       	ori	r24, 0x08	; 8
    79d6:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    79d8:	f7 01       	movw	r30, r14
    79da:	80 81       	ld	r24, Z
    79dc:	8e 7f       	andi	r24, 0xFE	; 254
    79de:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    79e0:	f8 01       	movw	r30, r16
    79e2:	80 81       	ld	r24, Z
    79e4:	80 61       	ori	r24, 0x10	; 16
    79e6:	80 83       	st	Z, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    79e8:	1f 91       	pop	r17
    79ea:	0f 91       	pop	r16
    79ec:	ff 90       	pop	r15
    79ee:	ef 90       	pop	r14
    79f0:	08 95       	ret

000079f2 <USB_Init>:

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    79f2:	e7 ed       	ldi	r30, 0xD7	; 215
    79f4:	f0 e0       	ldi	r31, 0x00	; 0
    79f6:	80 81       	ld	r24, Z
    79f8:	81 60       	ori	r24, 0x01	; 1
    79fa:	80 83       	st	Z, r24
	  USB_REG_Off();

	if (!(USB_Options & USB_OPT_MANUAL_PLL))
	{
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
    79fc:	8a e4       	ldi	r24, 0x4A	; 74
    79fe:	82 bf       	out	0x32, r24	; 50
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    7a00:	81 e0       	ldi	r24, 0x01	; 1
    7a02:	80 93 b5 01 	sts	0x01B5, r24

	USB_ResetInterface();
}
    7a06:	b6 cf       	rjmp	.-148    	; 0x7974 <USB_ResetInterface>

00007a08 <USB_INT_DisableAllInterrupts>:
void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
    7a08:	e8 ed       	ldi	r30, 0xD8	; 216
    7a0a:	f0 e0       	ldi	r31, 0x00	; 0
    7a0c:	80 81       	ld	r24, Z
    7a0e:	8e 7f       	andi	r24, 0xFE	; 254
    7a10:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    7a12:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    7a16:	08 95       	ret

00007a18 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    7a18:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    7a1c:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    7a20:	08 95       	ret

00007a22 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    7a22:	1f 92       	push	r1
    7a24:	0f 92       	push	r0
    7a26:	0f b6       	in	r0, 0x3f	; 63
    7a28:	0f 92       	push	r0
    7a2a:	11 24       	eor	r1, r1
    7a2c:	2f 93       	push	r18
    7a2e:	3f 93       	push	r19
    7a30:	4f 93       	push	r20
    7a32:	5f 93       	push	r21
    7a34:	6f 93       	push	r22
    7a36:	7f 93       	push	r23
    7a38:	8f 93       	push	r24
    7a3a:	9f 93       	push	r25
    7a3c:	af 93       	push	r26
    7a3e:	bf 93       	push	r27
    7a40:	ef 93       	push	r30
    7a42:	ff 93       	push	r31
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    7a44:	80 91 da 00 	lds	r24, 0x00DA
		EVENT_USB_Device_StartOfFrame();
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    7a48:	80 ff       	sbrs	r24, 0
    7a4a:	1b c0       	rjmp	.+54     	; 0x7a82 <__vector_10+0x60>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    7a4c:	80 91 d8 00 	lds	r24, 0x00D8
    7a50:	80 ff       	sbrs	r24, 0
    7a52:	17 c0       	rjmp	.+46     	; 0x7a82 <__vector_10+0x60>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    7a54:	80 91 da 00 	lds	r24, 0x00DA
    7a58:	8e 7f       	andi	r24, 0xFE	; 254
    7a5a:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    7a5e:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    7a62:	80 ff       	sbrs	r24, 0
    7a64:	0b c0       	rjmp	.+22     	; 0x7a7c <__vector_10+0x5a>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    7a66:	80 e1       	ldi	r24, 0x10	; 16
    7a68:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    7a6a:	82 e1       	ldi	r24, 0x12	; 18
    7a6c:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    7a6e:	09 b4       	in	r0, 0x29	; 41
    7a70:	00 fe       	sbrs	r0, 0
    7a72:	fd cf       	rjmp	.-6      	; 0x7a6e <__vector_10+0x4c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    7a74:	81 e0       	ldi	r24, 0x01	; 1
    7a76:	8e bb       	out	0x1e, r24	; 30
			EVENT_USB_Device_Connect();
    7a78:	3b d2       	rcall	.+1142   	; 0x7ef0 <USB_Event_Stub>
    7a7a:	03 c0       	rjmp	.+6      	; 0x7a82 <__vector_10+0x60>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    7a7c:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    7a7e:	1e ba       	out	0x1e, r1	; 30
			EVENT_USB_Device_Disconnect();
    7a80:	37 d2       	rcall	.+1134   	; 0x7ef0 <USB_Event_Stub>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    7a82:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    7a86:	80 ff       	sbrs	r24, 0
    7a88:	17 c0       	rjmp	.+46     	; 0x7ab8 <__vector_10+0x96>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    7a8a:	80 91 e2 00 	lds	r24, 0x00E2
    7a8e:	80 ff       	sbrs	r24, 0
    7a90:	13 c0       	rjmp	.+38     	; 0x7ab8 <__vector_10+0x96>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    7a92:	80 91 e2 00 	lds	r24, 0x00E2
    7a96:	8e 7f       	andi	r24, 0xFE	; 254
    7a98:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    7a9c:	80 91 e2 00 	lds	r24, 0x00E2
    7aa0:	80 61       	ori	r24, 0x10	; 16
    7aa2:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    7aa6:	80 91 d8 00 	lds	r24, 0x00D8
    7aaa:	80 62       	ori	r24, 0x20	; 32
    7aac:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    7ab0:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    7ab2:	85 e0       	ldi	r24, 0x05	; 5
    7ab4:	8e bb       	out	0x1e, r24	; 30
		EVENT_USB_Device_Suspend();
    7ab6:	1c d2       	rcall	.+1080   	; 0x7ef0 <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    7ab8:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    7abc:	84 ff       	sbrs	r24, 4
    7abe:	2c c0       	rjmp	.+88     	; 0x7b18 <__vector_10+0xf6>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    7ac0:	80 91 e2 00 	lds	r24, 0x00E2
    7ac4:	84 ff       	sbrs	r24, 4
    7ac6:	28 c0       	rjmp	.+80     	; 0x7b18 <__vector_10+0xf6>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    7ac8:	80 e1       	ldi	r24, 0x10	; 16
    7aca:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    7acc:	82 e1       	ldi	r24, 0x12	; 18
    7ace:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    7ad0:	09 b4       	in	r0, 0x29	; 41
    7ad2:	00 fe       	sbrs	r0, 0
    7ad4:	fd cf       	rjmp	.-6      	; 0x7ad0 <__vector_10+0xae>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    7ad6:	80 91 d8 00 	lds	r24, 0x00D8
    7ada:	8f 7d       	andi	r24, 0xDF	; 223
    7adc:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    7ae0:	80 91 e1 00 	lds	r24, 0x00E1
    7ae4:	8f 7e       	andi	r24, 0xEF	; 239
    7ae6:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    7aea:	80 91 e2 00 	lds	r24, 0x00E2
    7aee:	8f 7e       	andi	r24, 0xEF	; 239
    7af0:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    7af4:	80 91 e2 00 	lds	r24, 0x00E2
    7af8:	81 60       	ori	r24, 0x01	; 1
    7afa:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    7afe:	80 91 b4 01 	lds	r24, 0x01B4
    7b02:	88 23       	and	r24, r24
    7b04:	31 f4       	brne	.+12     	; 0x7b12 <__vector_10+0xf0>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    7b06:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    7b0a:	87 fd       	sbrc	r24, 7
    7b0c:	02 c0       	rjmp	.+4      	; 0x7b12 <__vector_10+0xf0>
    7b0e:	81 e0       	ldi	r24, 0x01	; 1
    7b10:	01 c0       	rjmp	.+2      	; 0x7b14 <__vector_10+0xf2>
    7b12:	84 e0       	ldi	r24, 0x04	; 4
    7b14:	8e bb       	out	0x1e, r24	; 30

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    7b16:	ec d1       	rcall	.+984    	; 0x7ef0 <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    7b18:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    7b1c:	83 ff       	sbrs	r24, 3
    7b1e:	21 c0       	rjmp	.+66     	; 0x7b62 <__vector_10+0x140>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    7b20:	80 91 e2 00 	lds	r24, 0x00E2
    7b24:	83 ff       	sbrs	r24, 3
    7b26:	1d c0       	rjmp	.+58     	; 0x7b62 <__vector_10+0x140>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    7b28:	80 91 e1 00 	lds	r24, 0x00E1
    7b2c:	87 7f       	andi	r24, 0xF7	; 247
    7b2e:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    7b32:	82 e0       	ldi	r24, 0x02	; 2
    7b34:	8e bb       	out	0x1e, r24	; 30
		USB_Device_ConfigurationNumber = 0;
    7b36:	10 92 b4 01 	sts	0x01B4, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    7b3a:	80 91 e1 00 	lds	r24, 0x00E1
    7b3e:	8e 7f       	andi	r24, 0xFE	; 254
    7b40:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    7b44:	80 91 e2 00 	lds	r24, 0x00E2
    7b48:	8e 7f       	andi	r24, 0xFE	; 254
    7b4a:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    7b4e:	80 91 e2 00 	lds	r24, 0x00E2
    7b52:	80 61       	ori	r24, 0x10	; 16
    7b54:	80 93 e2 00 	sts	0x00E2, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    7b58:	80 e0       	ldi	r24, 0x00	; 0
    7b5a:	60 e0       	ldi	r22, 0x00	; 0
    7b5c:	42 e0       	ldi	r20, 0x02	; 2
    7b5e:	d8 de       	rcall	.-592    	; 0x7910 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    7b60:	c7 d1       	rcall	.+910    	; 0x7ef0 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    7b62:	ff 91       	pop	r31
    7b64:	ef 91       	pop	r30
    7b66:	bf 91       	pop	r27
    7b68:	af 91       	pop	r26
    7b6a:	9f 91       	pop	r25
    7b6c:	8f 91       	pop	r24
    7b6e:	7f 91       	pop	r23
    7b70:	6f 91       	pop	r22
    7b72:	5f 91       	pop	r21
    7b74:	4f 91       	pop	r20
    7b76:	3f 91       	pop	r19
    7b78:	2f 91       	pop	r18
    7b7a:	0f 90       	pop	r0
    7b7c:	0f be       	out	0x3f, r0	; 63
    7b7e:	0f 90       	pop	r0
    7b80:	1f 90       	pop	r1
    7b82:	18 95       	reti

00007b84 <Endpoint_Write_Control_Stream_LE>:
    7b84:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    7b86:	40 91 bc 01 	lds	r20, 0x01BC
    7b8a:	50 91 bd 01 	lds	r21, 0x01BD
    7b8e:	46 17       	cp	r20, r22
    7b90:	57 07       	cpc	r21, r23
    7b92:	18 f4       	brcc	.+6      	; 0x7b9a <Endpoint_Write_Control_Stream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    7b94:	f9 01       	movw	r30, r18
    7b96:	90 e0       	ldi	r25, 0x00	; 0
    7b98:	44 c0       	rjmp	.+136    	; 0x7c22 <Endpoint_Write_Control_Stream_LE+0x9e>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    7b9a:	61 15       	cp	r22, r1
    7b9c:	71 05       	cpc	r23, r1
    7b9e:	11 f0       	breq	.+4      	; 0x7ba4 <Endpoint_Write_Control_Stream_LE+0x20>
    7ba0:	ab 01       	movw	r20, r22
    7ba2:	f8 cf       	rjmp	.-16     	; 0x7b94 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7ba4:	80 91 e8 00 	lds	r24, 0x00E8
    7ba8:	8e 77       	andi	r24, 0x7E	; 126
    7baa:	80 93 e8 00 	sts	0x00E8, r24
    7bae:	40 e0       	ldi	r20, 0x00	; 0
    7bb0:	50 e0       	ldi	r21, 0x00	; 0
    7bb2:	f0 cf       	rjmp	.-32     	; 0x7b94 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    7bb4:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    7bb6:	88 23       	and	r24, r24
    7bb8:	09 f4       	brne	.+2      	; 0x7bbc <Endpoint_Write_Control_Stream_LE+0x38>
    7bba:	44 c0       	rjmp	.+136    	; 0x7c44 <Endpoint_Write_Control_Stream_LE+0xc0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    7bbc:	85 30       	cpi	r24, 0x05	; 5
    7bbe:	09 f4       	brne	.+2      	; 0x7bc2 <Endpoint_Write_Control_Stream_LE+0x3e>
    7bc0:	43 c0       	rjmp	.+134    	; 0x7c48 <Endpoint_Write_Control_Stream_LE+0xc4>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7bc2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    7bc6:	83 ff       	sbrs	r24, 3
    7bc8:	02 c0       	rjmp	.+4      	; 0x7bce <Endpoint_Write_Control_Stream_LE+0x4a>
    7bca:	81 e0       	ldi	r24, 0x01	; 1
    7bcc:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7bce:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    7bd2:	82 fd       	sbrc	r24, 2
    7bd4:	31 c0       	rjmp	.+98     	; 0x7c38 <Endpoint_Write_Control_Stream_LE+0xb4>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    7bd6:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    7bda:	80 ff       	sbrs	r24, 0
    7bdc:	22 c0       	rjmp	.+68     	; 0x7c22 <Endpoint_Write_Control_Stream_LE+0x9e>
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    7bde:	80 91 f3 00 	lds	r24, 0x00F3
    7be2:	90 91 f2 00 	lds	r25, 0x00F2
    7be6:	78 2f       	mov	r23, r24
    7be8:	60 e0       	ldi	r22, 0x00	; 0
    7bea:	29 2f       	mov	r18, r25
    7bec:	30 e0       	ldi	r19, 0x00	; 0
    7bee:	26 2b       	or	r18, r22
    7bf0:	37 2b       	or	r19, r23
    7bf2:	07 c0       	rjmp	.+14     	; 0x7c02 <Endpoint_Write_Control_Stream_LE+0x7e>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    7bf4:	81 91       	ld	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    7bf6:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    7bfa:	41 50       	subi	r20, 0x01	; 1
    7bfc:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    7bfe:	2f 5f       	subi	r18, 0xFF	; 255
    7c00:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    7c02:	41 15       	cp	r20, r1
    7c04:	51 05       	cpc	r21, r1
    7c06:	19 f0       	breq	.+6      	; 0x7c0e <Endpoint_Write_Control_Stream_LE+0x8a>
    7c08:	28 30       	cpi	r18, 0x08	; 8
    7c0a:	31 05       	cpc	r19, r1
    7c0c:	98 f3       	brcs	.-26     	; 0x7bf4 <Endpoint_Write_Control_Stream_LE+0x70>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    7c0e:	90 e0       	ldi	r25, 0x00	; 0
    7c10:	28 30       	cpi	r18, 0x08	; 8
    7c12:	31 05       	cpc	r19, r1
    7c14:	09 f4       	brne	.+2      	; 0x7c18 <Endpoint_Write_Control_Stream_LE+0x94>
    7c16:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7c18:	80 91 e8 00 	lds	r24, 0x00E8
    7c1c:	8e 77       	andi	r24, 0x7E	; 126
    7c1e:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    7c22:	41 15       	cp	r20, r1
    7c24:	51 05       	cpc	r21, r1
    7c26:	31 f6       	brne	.-116    	; 0x7bb4 <Endpoint_Write_Control_Stream_LE+0x30>
    7c28:	99 23       	and	r25, r25
    7c2a:	21 f6       	brne	.-120    	; 0x7bb4 <Endpoint_Write_Control_Stream_LE+0x30>
    7c2c:	05 c0       	rjmp	.+10     	; 0x7c38 <Endpoint_Write_Control_Stream_LE+0xb4>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    7c2e:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    7c30:	88 23       	and	r24, r24
    7c32:	41 f0       	breq	.+16     	; 0x7c44 <Endpoint_Write_Control_Stream_LE+0xc0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    7c34:	85 30       	cpi	r24, 0x05	; 5
    7c36:	41 f0       	breq	.+16     	; 0x7c48 <Endpoint_Write_Control_Stream_LE+0xc4>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7c38:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    7c3c:	82 ff       	sbrs	r24, 2
    7c3e:	f7 cf       	rjmp	.-18     	; 0x7c2e <Endpoint_Write_Control_Stream_LE+0xaa>
    7c40:	80 e0       	ldi	r24, 0x00	; 0
    7c42:	08 95       	ret
    7c44:	82 e0       	ldi	r24, 0x02	; 2
    7c46:	08 95       	ret
    7c48:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    7c4a:	08 95       	ret

00007c4c <Endpoint_Read_Control_Stream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    7c4c:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    7c4e:	61 15       	cp	r22, r1
    7c50:	71 05       	cpc	r23, r1
    7c52:	29 f4       	brne	.+10     	; 0x7c5e <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    7c54:	80 91 e8 00 	lds	r24, 0x00E8
    7c58:	8b 77       	andi	r24, 0x7B	; 123
    7c5a:	80 93 e8 00 	sts	0x00E8, r24
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    7c5e:	f9 01       	movw	r30, r18
    7c60:	26 c0       	rjmp	.+76     	; 0x7cae <Endpoint_Read_Control_Stream_LE+0x62>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    7c62:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    7c64:	88 23       	and	r24, r24
    7c66:	91 f1       	breq	.+100    	; 0x7ccc <Endpoint_Read_Control_Stream_LE+0x80>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    7c68:	85 30       	cpi	r24, 0x05	; 5
    7c6a:	91 f1       	breq	.+100    	; 0x7cd0 <Endpoint_Read_Control_Stream_LE+0x84>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7c6c:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    7c70:	83 ff       	sbrs	r24, 3
    7c72:	02 c0       	rjmp	.+4      	; 0x7c78 <Endpoint_Read_Control_Stream_LE+0x2c>
    7c74:	81 e0       	ldi	r24, 0x01	; 1
    7c76:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7c78:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    7c7c:	82 ff       	sbrs	r24, 2
    7c7e:	f1 cf       	rjmp	.-30     	; 0x7c62 <Endpoint_Read_Control_Stream_LE+0x16>
    7c80:	06 c0       	rjmp	.+12     	; 0x7c8e <Endpoint_Read_Control_Stream_LE+0x42>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    7c82:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    7c86:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    7c88:	61 50       	subi	r22, 0x01	; 1
    7c8a:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    7c8c:	59 f0       	breq	.+22     	; 0x7ca4 <Endpoint_Read_Control_Stream_LE+0x58>
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    7c8e:	20 91 f3 00 	lds	r18, 0x00F3
    7c92:	80 91 f2 00 	lds	r24, 0x00F2
    7c96:	32 2f       	mov	r19, r18
    7c98:	20 e0       	ldi	r18, 0x00	; 0
    7c9a:	90 e0       	ldi	r25, 0x00	; 0
    7c9c:	82 2b       	or	r24, r18
    7c9e:	93 2b       	or	r25, r19
    7ca0:	89 2b       	or	r24, r25
    7ca2:	79 f7       	brne	.-34     	; 0x7c82 <Endpoint_Read_Control_Stream_LE+0x36>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    7ca4:	80 91 e8 00 	lds	r24, 0x00E8
    7ca8:	8b 77       	andi	r24, 0x7B	; 123
    7caa:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    7cae:	61 15       	cp	r22, r1
    7cb0:	71 05       	cpc	r23, r1
    7cb2:	b9 f6       	brne	.-82     	; 0x7c62 <Endpoint_Read_Control_Stream_LE+0x16>
    7cb4:	05 c0       	rjmp	.+10     	; 0x7cc0 <Endpoint_Read_Control_Stream_LE+0x74>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    7cb6:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    7cb8:	88 23       	and	r24, r24
    7cba:	41 f0       	breq	.+16     	; 0x7ccc <Endpoint_Read_Control_Stream_LE+0x80>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    7cbc:	85 30       	cpi	r24, 0x05	; 5
    7cbe:	41 f0       	breq	.+16     	; 0x7cd0 <Endpoint_Read_Control_Stream_LE+0x84>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    7cc0:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    7cc4:	80 ff       	sbrs	r24, 0
    7cc6:	f7 cf       	rjmp	.-18     	; 0x7cb6 <Endpoint_Read_Control_Stream_LE+0x6a>
    7cc8:	80 e0       	ldi	r24, 0x00	; 0
    7cca:	08 95       	ret
    7ccc:	82 e0       	ldi	r24, 0x02	; 2
    7cce:	08 95       	ret
    7cd0:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    7cd2:	08 95       	ret

00007cd4 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    7cd4:	0f 93       	push	r16
    7cd6:	1f 93       	push	r17
    7cd8:	df 93       	push	r29
    7cda:	cf 93       	push	r28
    7cdc:	00 d0       	rcall	.+0      	; 0x7cde <USB_Device_ProcessControlRequest+0xa>
    7cde:	cd b7       	in	r28, 0x3d	; 61
    7ce0:	de b7       	in	r29, 0x3e	; 62
    7ce2:	e6 eb       	ldi	r30, 0xB6	; 182
    7ce4:	f1 e0       	ldi	r31, 0x01	; 1
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    7ce6:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    7cea:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    7cec:	81 e0       	ldi	r24, 0x01	; 1
    7cee:	ee 3b       	cpi	r30, 0xBE	; 190
    7cf0:	f8 07       	cpc	r31, r24
    7cf2:	c9 f7       	brne	.-14     	; 0x7ce6 <USB_Device_ProcessControlRequest+0x12>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    7cf4:	1e dd       	rcall	.-1476   	; 0x7732 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7cf6:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    7cfa:	83 ff       	sbrs	r24, 3
    7cfc:	e4 c0       	rjmp	.+456    	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    7cfe:	80 91 b6 01 	lds	r24, 0x01B6

		switch (USB_ControlRequest.bRequest)
    7d02:	90 91 b7 01 	lds	r25, 0x01B7
    7d06:	95 30       	cpi	r25, 0x05	; 5
    7d08:	09 f4       	brne	.+2      	; 0x7d0c <USB_Device_ProcessControlRequest+0x38>
    7d0a:	6d c0       	rjmp	.+218    	; 0x7de6 <USB_Device_ProcessControlRequest+0x112>
    7d0c:	96 30       	cpi	r25, 0x06	; 6
    7d0e:	40 f4       	brcc	.+16     	; 0x7d20 <USB_Device_ProcessControlRequest+0x4c>
    7d10:	91 30       	cpi	r25, 0x01	; 1
    7d12:	81 f1       	breq	.+96     	; 0x7d74 <USB_Device_ProcessControlRequest+0xa0>
    7d14:	91 30       	cpi	r25, 0x01	; 1
    7d16:	70 f0       	brcs	.+28     	; 0x7d34 <USB_Device_ProcessControlRequest+0x60>
    7d18:	93 30       	cpi	r25, 0x03	; 3
    7d1a:	09 f0       	breq	.+2      	; 0x7d1e <USB_Device_ProcessControlRequest+0x4a>
    7d1c:	d4 c0       	rjmp	.+424    	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
    7d1e:	2a c0       	rjmp	.+84     	; 0x7d74 <USB_Device_ProcessControlRequest+0xa0>
    7d20:	98 30       	cpi	r25, 0x08	; 8
    7d22:	09 f4       	brne	.+2      	; 0x7d26 <USB_Device_ProcessControlRequest+0x52>
    7d24:	a3 c0       	rjmp	.+326    	; 0x7e6c <USB_Device_ProcessControlRequest+0x198>
    7d26:	99 30       	cpi	r25, 0x09	; 9
    7d28:	09 f4       	brne	.+2      	; 0x7d2c <USB_Device_ProcessControlRequest+0x58>
    7d2a:	b2 c0       	rjmp	.+356    	; 0x7e90 <USB_Device_ProcessControlRequest+0x1bc>
    7d2c:	96 30       	cpi	r25, 0x06	; 6
    7d2e:	09 f0       	breq	.+2      	; 0x7d32 <USB_Device_ProcessControlRequest+0x5e>
    7d30:	ca c0       	rjmp	.+404    	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
    7d32:	7c c0       	rjmp	.+248    	; 0x7e2c <USB_Device_ProcessControlRequest+0x158>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    7d34:	80 38       	cpi	r24, 0x80	; 128
    7d36:	09 f4       	brne	.+2      	; 0x7d3a <USB_Device_ProcessControlRequest+0x66>
    7d38:	c6 c0       	rjmp	.+396    	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
    7d3a:	82 38       	cpi	r24, 0x82	; 130
    7d3c:	09 f0       	breq	.+2      	; 0x7d40 <USB_Device_ProcessControlRequest+0x6c>
    7d3e:	c3 c0       	rjmp	.+390    	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    7d40:	80 91 ba 01 	lds	r24, 0x01BA
    7d44:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7d46:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    7d4a:	80 91 eb 00 	lds	r24, 0x00EB
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7d4e:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7d52:	20 91 e8 00 	lds	r18, 0x00E8
    7d56:	27 7f       	andi	r18, 0xF7	; 247
    7d58:	20 93 e8 00 	sts	0x00E8, r18
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    7d5c:	90 e0       	ldi	r25, 0x00	; 0
    7d5e:	25 e0       	ldi	r18, 0x05	; 5
    7d60:	96 95       	lsr	r25
    7d62:	87 95       	ror	r24
    7d64:	2a 95       	dec	r18
    7d66:	e1 f7       	brne	.-8      	; 0x7d60 <USB_Device_ProcessControlRequest+0x8c>
    7d68:	81 70       	andi	r24, 0x01	; 1
    7d6a:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    7d6e:	10 92 f1 00 	sts	0x00F1, r1
    7d72:	87 c0       	rjmp	.+270    	; 0x7e82 <USB_Device_ProcessControlRequest+0x1ae>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    7d74:	88 23       	and	r24, r24
    7d76:	19 f0       	breq	.+6      	; 0x7d7e <USB_Device_ProcessControlRequest+0xaa>
    7d78:	82 30       	cpi	r24, 0x02	; 2
    7d7a:	09 f0       	breq	.+2      	; 0x7d7e <USB_Device_ProcessControlRequest+0xaa>
    7d7c:	a4 c0       	rjmp	.+328    	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    7d7e:	8f 71       	andi	r24, 0x1F	; 31
    7d80:	82 30       	cpi	r24, 0x02	; 2
    7d82:	09 f0       	breq	.+2      	; 0x7d86 <USB_Device_ProcessControlRequest+0xb2>
    7d84:	a0 c0       	rjmp	.+320    	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    7d86:	80 91 b8 01 	lds	r24, 0x01B8
    7d8a:	88 23       	and	r24, r24
    7d8c:	31 f5       	brne	.+76     	; 0x7dda <USB_Device_ProcessControlRequest+0x106>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    7d8e:	20 91 ba 01 	lds	r18, 0x01BA
    7d92:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    7d94:	09 f4       	brne	.+2      	; 0x7d98 <USB_Device_ProcessControlRequest+0xc4>
    7d96:	97 c0       	rjmp	.+302    	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7d98:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    7d9c:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    7da0:	80 ff       	sbrs	r24, 0
    7da2:	1b c0       	rjmp	.+54     	; 0x7dda <USB_Device_ProcessControlRequest+0x106>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    7da4:	93 30       	cpi	r25, 0x03	; 3
    7da6:	21 f4       	brne	.+8      	; 0x7db0 <USB_Device_ProcessControlRequest+0xdc>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    7da8:	80 91 eb 00 	lds	r24, 0x00EB
    7dac:	80 62       	ori	r24, 0x20	; 32
    7dae:	13 c0       	rjmp	.+38     	; 0x7dd6 <USB_Device_ProcessControlRequest+0x102>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    7db0:	80 91 eb 00 	lds	r24, 0x00EB
    7db4:	80 61       	ori	r24, 0x10	; 16
    7db6:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    7dba:	81 e0       	ldi	r24, 0x01	; 1
    7dbc:	90 e0       	ldi	r25, 0x00	; 0
    7dbe:	02 c0       	rjmp	.+4      	; 0x7dc4 <USB_Device_ProcessControlRequest+0xf0>
    7dc0:	88 0f       	add	r24, r24
    7dc2:	99 1f       	adc	r25, r25
    7dc4:	2a 95       	dec	r18
    7dc6:	e2 f7       	brpl	.-8      	; 0x7dc0 <USB_Device_ProcessControlRequest+0xec>
    7dc8:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    7dcc:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    7dd0:	80 91 eb 00 	lds	r24, 0x00EB
    7dd4:	88 60       	ori	r24, 0x08	; 8
    7dd6:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7dda:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7dde:	80 91 e8 00 	lds	r24, 0x00E8
    7de2:	87 7f       	andi	r24, 0xF7	; 247
    7de4:	51 c0       	rjmp	.+162    	; 0x7e88 <USB_Device_ProcessControlRequest+0x1b4>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    7de6:	88 23       	and	r24, r24
    7de8:	09 f0       	breq	.+2      	; 0x7dec <USB_Device_ProcessControlRequest+0x118>
    7dea:	6d c0       	rjmp	.+218    	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
    7dec:	10 91 b8 01 	lds	r17, 0x01B8
    7df0:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    7df2:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    7df4:	f8 94       	cli
    7df6:	80 91 e8 00 	lds	r24, 0x00E8
    7dfa:	87 7f       	andi	r24, 0xF7	; 247
    7dfc:	80 93 e8 00 	sts	0x00E8, r24
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();
				
	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    7e00:	9a dd       	rcall	.-1228   	; 0x7936 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    7e02:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    7e06:	80 ff       	sbrs	r24, 0
    7e08:	fc cf       	rjmp	.-8      	; 0x7e02 <USB_Device_ProcessControlRequest+0x12e>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				uint8_t Temp = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    7e0a:	80 91 e3 00 	lds	r24, 0x00E3
    7e0e:	80 78       	andi	r24, 0x80	; 128
    7e10:	81 2b       	or	r24, r17

				UDADDR = Temp;
    7e12:	80 93 e3 00 	sts	0x00E3, r24
				UDADDR = Temp | (1 << ADDEN);
    7e16:	80 68       	ori	r24, 0x80	; 128
    7e18:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    7e1c:	11 23       	and	r17, r17
    7e1e:	11 f4       	brne	.+4      	; 0x7e24 <USB_Device_ProcessControlRequest+0x150>
    7e20:	82 e0       	ldi	r24, 0x02	; 2
    7e22:	01 c0       	rjmp	.+2      	; 0x7e26 <USB_Device_ProcessControlRequest+0x152>
    7e24:	83 e0       	ldi	r24, 0x03	; 3
    7e26:	8e bb       	out	0x1e, r24	; 30
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    7e28:	0f bf       	out	0x3f, r16	; 63
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;				
				#endif
				
				GCC_MEMORY_BARRIER();
    7e2a:	4d c0       	rjmp	.+154    	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    7e2c:	80 58       	subi	r24, 0x80	; 128
    7e2e:	82 30       	cpi	r24, 0x02	; 2
    7e30:	08 f0       	brcs	.+2      	; 0x7e34 <USB_Device_ProcessControlRequest+0x160>
    7e32:	49 c0       	rjmp	.+146    	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    7e34:	80 91 b8 01 	lds	r24, 0x01B8
    7e38:	90 91 b9 01 	lds	r25, 0x01B9
    7e3c:	60 91 ba 01 	lds	r22, 0x01BA
    7e40:	ae 01       	movw	r20, r28
    7e42:	4f 5f       	subi	r20, 0xFF	; 255
    7e44:	5f 4f       	sbci	r21, 0xFF	; 255
    7e46:	36 dd       	rcall	.-1428   	; 0x78b4 <CALLBACK_USB_GetDescriptor>
    7e48:	bc 01       	movw	r22, r24
    7e4a:	00 97       	sbiw	r24, 0x00	; 0
    7e4c:	09 f4       	brne	.+2      	; 0x7e50 <USB_Device_ProcessControlRequest+0x17c>
    7e4e:	3b c0       	rjmp	.+118    	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7e50:	80 91 e8 00 	lds	r24, 0x00E8
    7e54:	87 7f       	andi	r24, 0xF7	; 247
    7e56:	80 93 e8 00 	sts	0x00E8, r24
	}

	Endpoint_ClearSETUP();

	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
    7e5a:	89 81       	ldd	r24, Y+1	; 0x01
    7e5c:	9a 81       	ldd	r25, Y+2	; 0x02
    7e5e:	92 de       	rcall	.-732    	; 0x7b84 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    7e60:	80 91 e8 00 	lds	r24, 0x00E8
    7e64:	8b 77       	andi	r24, 0x7B	; 123
    7e66:	80 93 e8 00 	sts	0x00E8, r24
    7e6a:	2d c0       	rjmp	.+90     	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    7e6c:	80 38       	cpi	r24, 0x80	; 128
    7e6e:	59 f5       	brne	.+86     	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7e70:	80 91 e8 00 	lds	r24, 0x00E8
    7e74:	87 7f       	andi	r24, 0xF7	; 247
    7e76:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    7e7a:	80 91 b4 01 	lds	r24, 0x01B4
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    7e7e:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7e82:	80 91 e8 00 	lds	r24, 0x00E8
    7e86:	8e 77       	andi	r24, 0x7E	; 126
    7e88:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    7e8c:	54 dd       	rcall	.-1368   	; 0x7936 <Endpoint_ClearStatusStage>
    7e8e:	1b c0       	rjmp	.+54     	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    7e90:	88 23       	and	r24, r24
    7e92:	c9 f4       	brne	.+50     	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    7e94:	90 91 b8 01 	lds	r25, 0x01B8
    7e98:	92 30       	cpi	r25, 0x02	; 2
    7e9a:	a8 f4       	brcc	.+42     	; 0x7ec6 <USB_Device_ProcessControlRequest+0x1f2>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7e9c:	80 91 e8 00 	lds	r24, 0x00E8
    7ea0:	87 7f       	andi	r24, 0xF7	; 247
    7ea2:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    7ea6:	90 93 b4 01 	sts	0x01B4, r25

	Endpoint_ClearStatusStage();
    7eaa:	45 dd       	rcall	.-1398   	; 0x7936 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    7eac:	80 91 b4 01 	lds	r24, 0x01B4
    7eb0:	88 23       	and	r24, r24
    7eb2:	31 f4       	brne	.+12     	; 0x7ec0 <USB_Device_ProcessControlRequest+0x1ec>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    7eb4:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    7eb8:	87 fd       	sbrc	r24, 7
    7eba:	02 c0       	rjmp	.+4      	; 0x7ec0 <USB_Device_ProcessControlRequest+0x1ec>
    7ebc:	81 e0       	ldi	r24, 0x01	; 1
    7ebe:	01 c0       	rjmp	.+2      	; 0x7ec2 <USB_Device_ProcessControlRequest+0x1ee>
    7ec0:	84 e0       	ldi	r24, 0x04	; 4
    7ec2:	8e bb       	out	0x1e, r24	; 30

	EVENT_USB_Device_ConfigurationChanged();
    7ec4:	66 dc       	rcall	.-1844   	; 0x7792 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7ec6:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    7eca:	83 ff       	sbrs	r24, 3
    7ecc:	0a c0       	rjmp	.+20     	; 0x7ee2 <USB_Device_ProcessControlRequest+0x20e>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    7ece:	80 91 eb 00 	lds	r24, 0x00EB
    7ed2:	80 62       	ori	r24, 0x20	; 32
    7ed4:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7ed8:	80 91 e8 00 	lds	r24, 0x00E8
    7edc:	87 7f       	andi	r24, 0xF7	; 247
    7ede:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    7ee2:	0f 90       	pop	r0
    7ee4:	0f 90       	pop	r0
    7ee6:	cf 91       	pop	r28
    7ee8:	df 91       	pop	r29
    7eea:	1f 91       	pop	r17
    7eec:	0f 91       	pop	r16
    7eee:	08 95       	ret

00007ef0 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    7ef0:	08 95       	ret

00007ef2 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    7ef2:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    7ef4:	8e b3       	in	r24, 0x1e	; 30
    7ef6:	88 23       	and	r24, r24
    7ef8:	61 f0       	breq	.+24     	; 0x7f12 <USB_USBTask+0x20>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    7efa:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7efe:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7f02:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    7f06:	83 ff       	sbrs	r24, 3
    7f08:	01 c0       	rjmp	.+2      	; 0x7f0c <USB_USBTask+0x1a>
		  USB_Device_ProcessControlRequest();
    7f0a:	e4 de       	rcall	.-568    	; 0x7cd4 <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    7f0c:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7f0e:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    7f12:	1f 91       	pop	r17
    7f14:	08 95       	ret

00007f16 <_exit>:
    7f16:	f8 94       	cli

00007f18 <__stop_program>:
    7f18:	ff cf       	rjmp	.-2      	; 0x7f18 <__stop_program>
